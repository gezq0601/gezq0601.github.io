{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Welcome to MkDocs For full documentation visit mkdocs.org . Commands mkdocs new [dir-name] - Create a new project. mkdocs serve - Start the live-reloading docs server. mkdocs build - Build the documentation site. mkdocs -h - Print help message and exit. Project layout mkdocs.yml # The configuration file. docs/ index.md # The documentation homepage. ... # Other markdown pages, images and other files. About This Project is designed for studying cagd students.","title":"Home"},{"location":"#welcome-to-mkdocs","text":"For full documentation visit mkdocs.org .","title":"Welcome to MkDocs"},{"location":"#commands","text":"mkdocs new [dir-name] - Create a new project. mkdocs serve - Start the live-reloading docs server. mkdocs build - Build the documentation site. mkdocs -h - Print help message and exit.","title":"Commands"},{"location":"#project-layout","text":"mkdocs.yml # The configuration file. docs/ index.md # The documentation homepage. ... # Other markdown pages, images and other files.","title":"Project layout"},{"location":"#about","text":"This Project is designed for studying cagd students.","title":"About"},{"location":"about/","text":"StatusCode : 200 StatusDescription : OK Content : # Calliroe fuit filia ## Quis nequeo honore Lorem markdownum quippe esse paludes, silvarum factis sororis: traiecit quidem. **Tenebo e** in Argo! Iam locum amantes [exsangue](http://www.deteguntur.c... RawContent : HTTP/1.1 200 OK Transfer-Encoding: chunked Connection: keep-alive access-control-allow-origin: * Content-Type: text/plain; charset=utf-8 Date: Sun, 21 Jul 2024 12:08:43 GMT Server: nginx/1.14.2... Forms : {} Headers : {[Transfer-Encoding, chunked], [Connection, keep-alive], [access-control-allow-origin, *], [Content-Type, text/plain; charset=utf-8]...} Images : {} InputFields : {} Links : {} ParsedHtml : mshtml.HTMLDocumentClass RawContentLength : 3402","title":"About"},{"location":"cagd/barycentric_coordinates/","text":"","title":"Barycentric Coordinates"},{"location":"cagd/course_tasks/","text":"","title":"Course Tasks"},{"location":"cagd/pre-school_tasks/","text":"n\u6b21Bernstein\u57fa\u51fd\u6570\u7684\u7ed8\u5236 Description \u8f93\u5165 \\(n\\) \uff0c\u5728\u540c\u4e00\u4e2a\u56fe\u4e2d\u7ed8\u5236 \\(n+1\\) \u4e2a \\(Bernstein\\) \u57fa\u51fd\u6570\u7684\u56fe\u50cf Knowledge \\(Def\\) \uff08 \\(Bernstein\\) \u57fa\u51fd\u6570\uff09\uff1a \\(n\\) \u6b21 \\(Bernstein\\) \u57fa\u51fd\u6570\u4e3a \\(B_0^n(t), B_1^n(t),\\cdots,B_i^n(t),\\cdots,B_n^n(t)\\) \uff0c\u5b83\u4eec\u4f9d\u6b21\u4e3a\u4e8c\u6b21\u9879 \\([t+(1-t)]^n\\) \u5c55\u5f00\u540e\u7684\u5404\u9879\uff0c\u5176\u4e2d \\(B_i^n(t)\\) \u662f \\(Bernstein\\) \u591a\u9879\u5f0f\u3002 \\[ B_i^n(t) = \\begin{pmatrix} n \\\\ i \\end{pmatrix} (1-t)^{n-i} t^i, \\quad t\\in [0,1], \\quad i = 0, 1, \\cdots, n. \\] \\(Thinking\\) \uff1a \u7531\u8f93\u5165\u7684 \\(Bernstein\\) \u57fa\u51fd\u6570\u7684\u6b21\u6570 \\(n\\) \uff0c\u5229\u7528 \\(for\\) \u5faa\u73af\u4f9d\u6b21\u8ba1\u7b97\u5e76\u7ed8\u5236\u6bcf\u6761\u66f2\u7ebf \\(B_i^n(t),(i=0,1,\\cdots,n)\\) \u3002 \u5b9a\u4e49\u51fd\u6570\uff1a\u5b9e\u73b0 \\(Bernstein\\) \u57fa\u51fd\u6570\u7684\u5b9a\u4e49\u516c\u5f0f\uff0c\u5373\u7ed9\u5b9a\u81ea\u53d8\u91cf \\(t\\) \u8ba1\u7b97\u5bf9\u5e94\u7684\u51fd\u6570\u503c\u3002 Code # -*- coding: UTF-8 -*- \"\"\" @date-time: 7/28/2024 - 11:24 PM @author: gezq \"\"\" import numpy as np from matplotlib import pyplot as plt from math import factorial as fac # To solve the problem of plt plt.rcParams[\"font.sans-serif\"] = [\"SimHei\"] plt.rcParams[\"axes.unicode_minus\"] = False def bernstein(n, i, t): \"\"\" Calculate the values of Bernstein's function. :param n: the degree of the Bernstein's function. :param i: the order of the Bernstein's function. :param t: the array of self-variable of the Bernstein's function. :return: the values of Bernstein's function. \"\"\" return (fac(n) / (fac(i) * fac(n - i))) * pow(t, i) * pow(1 - t, n - i) def draw_bernstein(n): \"\"\" Draw the Bernstein's function. :param n: the degree of the Bernstein's function. :return: No return. \"\"\" t = np.linspace(0, 1) for i in range(n + 1): plt.plot(t, bernstein(n, i, t)) # Use the property of max value of Bernstein basis function plt.text(i / n, bernstein(n, i, i / n) * 1.02, f'$ B_{i}^{n} $') plt.title(f'{n}-order Bernstein basis functions') plt.show() if __name__ == '__main__': n = int(input(\"Please input the degree of Bernstein basis functions n=\")) draw_bernstein(n) Result n\u6b21B\u00e9zier\u66f2\u7ebf\u7684\u7ed8\u5236 Description \u8f93\u5165 \\(n\\) \uff0c\u9f20\u6807\u8f93\u5165 \\(n+1\\) \u4e2a\u70b9\uff0c\u7ed8\u5236\u4e00\u6761 \\(B\u00e9zier\\) \u66f2\u7ebf\uff0c\u540c\u65f6\u7ed8\u5236\u63a7\u5236\u591a\u8fb9\u5f62\u3002 \u70b9\u7528\u7a7a\u5fc3\u5706\u70b9\u8868\u793a\uff0c\u63a7\u5236\u591a\u8fb9\u5f62\u4e0e\u66f2\u7ebf\u7528\u4e0d\u540c\u989c\u8272\u533a\u5206\u3002 \u9f20\u6807\u8f93\u5165\u63a7\u5236\u9876\u70b9\uff0c\u6bcf\u4e2a\u70b9\u9644\u8fd1\u6807\u8bb0\u70b9\u5e8f\u5217\u53f7\uff08\u5373\u4e0b\u6807\uff09\u3002 Knowledge \\(Def\\) \uff08 \\(B\u00e9zier\\) \u66f2\u7ebf\uff09\uff1a \\(n\\) \u6b21 \\(B\u00e9zier\\) \u66f2\u7ebf\u7684\u5b9a\u4e49\u5982\u4e0b\uff0c\u5176\u4e2d \\(P_i\\) \u4e3a\u63a7\u5236\u70b9\uff0c \\(B_i^n(t)\\) \u4e3a \\(Bernstein\\) \u57fa\u51fd\u6570\u3002 \\[ \\mathbf{C}(t) = \\sum_{i=0}^n \\mathbf{P}_i B_i^n(t), \\quad t \\in [0,1]. \\] \\(Thinking\\) \uff1a \u5bfc\u5165 task01 \u4e2d\u8ba1\u7b97 \\(B_i^n(t)\\) \u7684\u51fd\u6570\u3002 \u5b9a\u4e49\u51fd\u6570\uff1a\u8ba1\u7b97\u6240\u6709 \\(Bernstein\\) \u57fa\u51fd\u6570\u5728 \\(t\\in[0,1]\\) \u4e4b\u95f4\u7684\u6240\u6709\u503c\u3002 \u601d\u8003\u70b9\uff1a\u7531 \\(B\u00e9zier\\) \u66f2\u7ebf\u7684\u5b9a\u4e49\uff08 \\(Bernstein\\) \u57fa\u51fd\u6570\u4e0e\u63a7\u5236\u70b9\uff09\u8ba1\u7b97\u5bf9\u5e94\u7684\u51fd\u6570\u503c\u2014\u2014\u7c7b\u4f3c\u77e9\u9635\u76f8\u4e58\u7684\u601d\u60f3\u3002 \u5b9a\u4e49\u51fd\u6570\uff1a\u7ed8\u5236\u56fe\u5f62( \\(B\u00e9zier\\) \u66f2\u7ebf\u3001\u63a7\u5236\u591a\u8fb9\u5f62\u53ca\u63a7\u5236\u9876\u70b9)\u3002 \u601d\u8003\u70b9\uff1a\u591a\u4e2a \\(Bernstein\\) \u57fa\u51fd\u6570\u7684\u503c\u7684\u5b58\u653e\u5f62\u5f0f\uff0c\u53ca\u540e\u7eed\u5982\u4f55\u83b7\u53d6 \\(B\u00e9zier\\) \u66f2\u7ebf\u7684\u51fd\u6570\u503c\u2014\u2014 DataFrame \u3002 \u601d\u8003\u70b9\uff1a\u9f20\u6807\u9009\u70b9\u2014\u2014\u672a\u4f7f\u7528 figure.canvas.mpl_connect \u7ed1\u5b9a\u4e8b\u4ef6\uff0c\u800c\u91c7\u7528\u66f4\u7b80\u4fbf\u7684 ginput() \u51fd\u6570\u76f4\u63a5\u83b7\u53d6\u70b9\u7684\u5750\u6807\u3002 \u4e3a\u4fbf\u4e8e\u540e\u7eed\u4ee3\u7801\u4e2d import task02 \uff0c\u56e0\u6b64\u8c03\u6574\u51fd\u6570\u4e2d\u53d8\u91cf\u4ee5\u53c2\u6570\u5f62\u5f0f\u4f20\u9012\uff0c\u907f\u514d\u4f7f\u7528\u5168\u5c40\u53d8\u91cf\uff0c\u589e\u5f3a\u4e86\u4ee3\u7801\u7684\u53ef\u91cd\u7528\u6027\u3002 Code # -*- coding: UTF-8 -*- \"\"\" @date-time: 7/29/2024 - 8:36 AM @author: gezq \"\"\" import numpy as np import pandas as pd from matplotlib import pyplot as plt import task01 import utils def calculate_bernstein(n): \"\"\" Calculate Bernstein values :param n: the degree of the Bernstein's function. :return: the DataFrame of the values of Bernstein's function. \"\"\" t = np.linspace(0, 1) df_bernstein = pd.DataFrame() # The values of each Bernstein function as a column store in df_bernstein. for i in range(n + 1): df_bernstein[i] = task01.bernstein(n, i, t) return df_bernstein def calculate_bezier(n, df_points): \"\"\" Calculate Bezier values :param n: the degree of the B\u00e9zier curve. :param df_points: the control points. :return: the DataFrame of the values of B\u00e9zier curve. \"\"\" df_bernstein = calculate_bernstein(n) # Calculate the values of B\u00e9zier curve df_result = df_bernstein.dot(df_points) return df_result def draw_bezier(n, df_points): \"\"\" Draw the B\u00e9zier curve :param n: the degree of the B\u00e9zier curve. :param df_points: the control points. :return: No return. \"\"\" df_result = calculate_bezier(n, df_points) # Draw B\u00e9zier curve and control polygon. df_result.plot(x='x', y='y', label='B\u00e9zier curve', color='b', ax=plt.gca()) df_points.plot(x='x', y='y', label='Control polygon', color='r', marker='o', markerfacecolor='w', ax=plt.gca()) utils.add_text_subscript(df_points) plt.legend() plt.show() if __name__ == '__main__': n = int(input(\"Please input the degree of B\u00e9zier curve n=\")) draw_bezier(n, utils.selection_point(n + 1, f'{n}-order B\u00e9zier curve')) Result n\u6b21B\u00e9zier\u66f2\u7ebf\u7684\u51e0\u4f55\u4f5c\u56fe\u6cd5 Description \u8f93\u5165 \\(n\\) \uff0c\u8f93\u5165\u53d8\u91cf \\(t\\) \uff0c\u9f20\u6807\u8f93\u5165 \\(n+1\\) \u4e2a\u70b9\uff0c\u7ed8\u5236\u4e00\u6761 \\(B\u00e9zier\\) \u66f2\u7ebf\u7684\u63a7\u5236\u591a\u8fb9\u5f62\uff0c\u540c\u65f6\u7ed8\u5236\u51e0\u4f55\u4f5c\u56fe\u6cd5\u8fc7\u7a0b\u4e2d\u6bcf\u4e2a\u70b9\u3001\u6bcf\u6761\u7ebf\u6bb5\uff0c\u6700\u540e\u7ed8\u5236\u66f2\u7ebf\u4e0a\u53c2\u6570\u4e3a$t\uffe5\u7684\u70b9\uff0c\u7528\u4e0d\u540c\u989c\u8272\u4e0e\u5176\u4ed6\u70b9\u533a\u5206\u3002 \u9f20\u6807\u8f93\u5165\u63a7\u5236\u9876\u70b9\uff0c\u6bcf\u4e2a\u70b9\u9644\u8fd1\u6807\u8bb0\u70b9\u5e8f\u5217\u53f7\uff08\u5373\u4e0b\u6807\uff09\u3002 Knowledge \\(Def\\) \uff08 \\(de\\ Casteljau\\) \u7b97\u6cd5\u9012\u63a8\u516c\u5f0f\uff09\uff1a\u5176\u4e2d \\(k\\) \u4e3a\u9012\u5f52\u8f6e\u6b21\u3002 \\[ \\mathbf P_i^k(t) = \\begin{cases} \\mathbf P_i, &k=0; \\quad i=0,1,\\cdots,n \\\\ (1 - t) \\mathbf P_{i}^{k-1}(t) + t\\mathbf P_{i+1}^{k-1}(t), \\quad &k=1,2,\\cdots,n;\\quad i=0,1,\\cdots,n - k. \\end{cases} \\] \\(Thinking\\) \u7ed8\u5236 \\(B\u00e9zier\\) \u66f2\u7ebf\u3001\u63a7\u5236\u591a\u8fb9\u5f62\u53ca\u63a7\u5236\u9876\u70b9\u4e0e task02 \u7c7b\u4f3c\u3002 \u601d\u8003\u70b9\uff1a\u9012\u63a8\u7b97\u6cd5\u7684\u5b9e\u73b0\u2014\u2014\u7531\u672c\u6b21\u63a7\u5236\u70b9\u8ba1\u7b97\u51fa\u4e0b\u4e00\u8f6e\u7684\u70b9\uff0c\u5c06\u672c\u6b21\u63a7\u5236\u70b9\u8986\u76d6\u540e\u518d\u7ed8\u5236\uff0c\u91cd\u590d \\(n\\) \u6b21\u6b64\u64cd\u4f5c\u3002 Code # -*- coding: UTF-8 -*- \"\"\" @date-time: 7/29/2024 - 11:32 AM @author: gezq \"\"\" from fractions import Fraction from matplotlib import pyplot as plt import task02 import utils def recursive_formula(df_points, i, t): \"\"\" deCasteljau recursive formula :param df_points: the control points of current time. :param i: the time index. :param t: the parameter value. :return: the result of recursive formula. \"\"\" return (1 - t) * df_points.iloc[i] + t * df_points.iloc[i + 1] def recursion(n, df_points, i, t): \"\"\" deCasteljau recursive algorithm :param n: the degree of the B\u00e9zier curve. :param df_points: the control points of current time. :param i: the time index. :param t: the parameter value. :return: the control points of next time. \"\"\" if i == 0: return df_points for j in range(n - i + 1): df_points.iloc[j] = recursive_formula(df_points, j, t) return df_points.iloc[:n - i + 1, :] def draw_bezier_geometry(n, df_points, t): \"\"\" Draw the B\u00e9zier curve of geometric processing. :param n: the degree of the B\u00e9zier curve. :param df_points: the control points. :param t: the parameter value. :return: No return. \"\"\" df_result = task02.calculate_bezier(n, df_points) # Unify the color of curve, 'k' is black. df_result.plot(x='x', y='y', label='B\u00e9zier curve', color='b', ax=plt.gca()) # Cycle n times for i in range(n + 1): df_points = recursion(n, df_points, i, t) df_points.plot(x='x', y='y', label=f'The {i} round', marker='o', markerfacecolor='w', ax=plt.gca()) utils.add_text_subscript_with_specify_superscript(df_points, i) plt.legend() plt.show() if __name__ == '__main__': n = int(input(\"Please input the degree of B\u00e9zier curve n=\")) # Import Fraction for handling the parameter t. t = Fraction(input(\"Please input the parameter t=\")) draw_bezier_geometry(n, utils.selection_point(n + 1, f'Geometric progressing of {n}-order B\u00e9zier curve (t={t})'), float(t)) Result B\u00e9zier\u66f2\u7ebf\u7684\u63d2\u503c Description \u7ed9\u5b9a \\(n+1\\) \u4e2a\u70b9\uff0c\u8981\u6c42\u7b97\u51fa \\(n\\) \u6b21 \\(B\u00e9zier\\) \u66f2\u7ebf\u7684\u63a7\u5236\u9876\u70b9\uff0c\u4f7f\u5f97 \\(n+1\\) \u4e2a\u70b9\u5728 \\(n\\) \u6b21 \\(B\u00e9zier\\) \u66f2\u7ebf\u4e0a\u3002 \u9f20\u6807\u8f93\u5165\u63a7\u5236\u9876\u70b9\uff0c\u6bcf\u4e2a\u70b9\u9644\u8fd1\u6807\u8bb0\u70b9\u5e8f\u5217\u53f7\uff08\u5373\u4e0b\u6807\uff09\u3002 Knowledge \\(Def\\) \uff08 \\(B\u00e9zier\\) \u66f2\u7ebf\u7684\u77e9\u9635\u5f62\u5f0f\uff09\uff1a \\(n\\) \u6b21 \\(B\u00e9zier\\) \u66f2\u7ebf\u7684\u77e9\u9635\u5f62\u5f0f\u5982\u4e0b\uff0c\u5176\u4e2d \\(P_i\\) \u4e3a\u63a7\u5236\u70b9\uff0c \\(B_i^n(t)\\) \u4e3a \\(Bernstein\\) \u57fa\u51fd\u6570\u3002 \\[ \\begin{align} \\mathbf{C}(t) &= \\sum_{i=0}^n \\mathbf{P}_i B_i^n(t), \\quad t \\in [0,1]. \\\\ &= \\begin{pmatrix} B_0^d(t) & B_1^d(t) & \\cdots & B_d^d(t) \\end{pmatrix} \\cdot \\begin{pmatrix} \\mathbf{P}_0 \\\\ \\mathbf{P}_1 \\\\ \\vdots \\\\ \\mathbf{P}_d \\end{pmatrix} \\end{align} \\] \u82e5\u7ed9\u5b9a\u4efb\u610f \\(n+1\\) \u4e2a\u70b9 \\(\\boldsymbol{v}_i(i=0,1,\\cdots,d)\\) \uff0c\u5373 \\(\\boldsymbol{v}_i = \\mathbf{C}(t_i)\\) \uff0c\u5219\u6709\u5982\u4e0b\u5f62\u5f0f\uff1a \\[ \\begin{align} \\begin{pmatrix} \\mathbf{C}(t_0) \\\\ \\mathbf{C}(t_1) \\\\ \\vdots \\\\ \\mathbf{C}(t_n) \\end{pmatrix} = \\begin{pmatrix} \\boldsymbol{v}_0 \\\\ \\boldsymbol{v}_1 \\\\ \\vdots \\\\ \\boldsymbol{v}_n \\end{pmatrix} &= \\begin{pmatrix} B_0^n(t_0) & B_1^n(t_0) & \\cdots & B_n^n(t_0) \\\\ B_0^n(t_1) & B_1^n(t_1) & \\cdots & B_n^n(t_1) \\\\ \\vdots & \\vdots & \\ddots & \\vdots \\\\ B_0^n(t_n) & B_1^n(t_n) & \\cdots & B_n^n(t_n) \\\\ \\end{pmatrix} \\cdot \\begin{pmatrix} \\mathbf{P}_0 \\\\ \\mathbf{P}_1 \\\\ \\vdots \\\\ \\mathbf{P}_n \\end{pmatrix} \\\\\\\\ \\begin{pmatrix} \\mathbf{P}_0 \\\\ \\mathbf{P}_1 \\\\ \\vdots \\\\ \\mathbf{P}_n \\end{pmatrix} &= {\\begin{pmatrix} B_0^n(t_0) & B_1^n(t_0) & \\cdots & B_n^n(t_0) \\\\ B_0^n(t_1) & B_1^n(t_1) & \\cdots & B_n^n(t_1) \\\\ \\vdots & \\vdots & \\ddots & \\vdots \\\\ B_0^n(t_n) & B_1^n(t_n) & \\cdots & B_n^n(t_n) \\\\ \\end{pmatrix}}^{-1} \\cdot \\begin{pmatrix} \\boldsymbol{v}_0 \\\\ \\boldsymbol{v}_1 \\\\ \\vdots \\\\ \\boldsymbol{v}_n \\end{pmatrix} \\end{align} \\] \u4e3a\u7b80\u4fbf\u8d77\u89c1\uff0c\u4e00\u822c\u53d6 \\(t_i = \\frac{i}{n}(i=0,1,\\cdots,n)\\) \uff0c\u5219\u53ef\u5f97\u5982\u4e0b\u5f62\u5f0f\uff1a \\[ \\begin{pmatrix} \\mathbf{P}_0 \\\\ \\mathbf{P}_1 \\\\ \\vdots \\\\ \\mathbf{P}_n \\end{pmatrix} = {\\begin{pmatrix} 1 & 0 & \\cdots & 0 \\\\ B_0^n(\\frac{1}{d}) & B_1^n(\\frac{1}{d}) & \\cdots & B_n^n(\\frac{1}{d}) \\\\ \\vdots & \\vdots & \\ddots & \\vdots \\\\ 0 & 0 & \\cdots & 1 \\\\ \\end{pmatrix}}^{-1} \\cdot \\begin{pmatrix} \\boldsymbol{v}_0 \\\\ \\boldsymbol{v}_1 \\\\ \\vdots \\\\ \\boldsymbol{v}_n \\end{pmatrix} \\] \u5c06\u4e0a\u8ff0\u77e9\u9635\u5f62\u5f0f\u5199\u4e3a\u7ebf\u6027\u65b9\u7a0b\u7ec4\u5f62\u5f0f\uff1a \\[ \\begin{cases} \\mathbf{P}_0 &= \\boldsymbol{v}_0 \\\\ \\mathbf{P}_n &= \\boldsymbol{v}_n \\\\ \\sum_{i=0}^{n} \\begin{pmatrix} n \\\\ i \\end{pmatrix} \\left( 1-\\frac{i}{n} \\right)^{n-i} \\left( \\frac{i}{n} \\right)^{i} \\mathbf{P}_j &= \\boldsymbol{v}_j,\\quad j=0,1,\\cdots,d-1. \\end{cases} \\] \u901a\u8fc7\u6c42\u89e3\u4e0a\u8ff0\u7ebf\u6027\u65b9\u7a0b\u7ec4\u4fbf\u53ef\u4ee5\u6c42\u51fa\u5bf9\u5e94 \\(n\\) \u6b21 \\(B\u00e9zier\\) \u66f2\u7ebf\u7684 \\(n+1\\) \u4e2a\u63a7\u5236\u9876\u70b9\u3002 \\(Thinking\\) \u7ed8\u5236 \\(B\u00e9zier\\) \u66f2\u7ebf\u3001\u63a7\u5236\u591a\u8fb9\u5f62\u53ca\u63a7\u5236\u9876\u70b9\u4e0e task02 , task03 \u7c7b\u4f3c\u3002 \u601d\u8003\u70b9\uff1a\u6c42\u89e3\u63a7\u5236\u9876\u70b9\u2014\u2014\u7531 \\(B\u00e9zier\\) \u66f2\u7ebf\u7684\u77e9\u9635\u5f62\u5f0f\u53ef\u7531\u7ed9\u5b9a\u7684 \\(n+1\\) \u4e2a\u70b9\u6c42\u89e3\u51fa \\(n+1\\) \u4e2a\u63a7\u5236\u9876\u70b9\u3002 Code # -*- coding: UTF-8 -*- \"\"\" @date-time: 7/29/2024 - 5:53 PM @author: gezq \"\"\" import numpy as np import pandas as pd from matplotlib import pyplot as plt import task02 import utils def calculate_control_points(n, df_points): \"\"\" Calculate control points from given points. :param n: the degree of the B\u00e9zier curve. :param df_points: the given points. :return: the control points. \"\"\" df_bernstein = task02.calculate_bernstein(n, np.linspace(0, 1, n + 1)) return pd.DataFrame(np.asmatrix(df_bernstein).I).dot(df_points) def draw_bezier_interpolation(n, df_points): \"\"\" Draw the B\u00e9zier curve of interpolation. :param n: the degree of the B\u00e9zier curve. :param df_points: the control points. :return: No return. \"\"\" df_control_points = calculate_control_points(n, df_points) df_result = task02.calculate_bezier(n, df_control_points) df_points.plot(x='x', y='y', label='Picked point', color='w', marker='o', markerfacecolor='k', ax=plt.gca()) df_result.plot(x='x', y='y', label='B\u00e9zier curve', color='b', ax=plt.gca()) df_control_points.plot(x='x', y='y', label='Control polygon', color='r', marker='o', markerfacecolor='w', ax=plt.gca()) utils.add_text_subscript(df_control_points) plt.xlabel(\"t\") plt.ylabel(\"u\") plt.xlim(xmin=0, xmax=1) plt.ylim(ymin=0, ymax=5) plt.legend() plt.show() if __name__ == '__main__': n = int(input(\"Please input the degree of Bernstein basis functions n=\")) draw_bezier_interpolation(n, utils.selection_point(n + 1, f'Interpolation of {n}-order B\u00e9zier curve')) Result n\u6b21B\u6837\u6761\u57fa\u51fd\u6570\u7684\u7ed8\u5236 Description \u8f93\u5165 \\(n\\) \uff0c\u5728\u540c\u4e00\u4e2a\u56fe\u4e2d\u7ed8\u5236 \\(n+1\\) \u4e2a \\(B\\) \u6837\u6761\u57fa\u51fd\u6570\u7684\u56fe\u50cf\u3002\u5747\u5300\u3001\u51c6\u5747\u5300\u3001\u975e\u5747\u5300\u7684\u60c5\u51b5\u90fd\u9700\u8981\u7ed8\u5236\u3002 \u7ed8\u5236 \\(B\\) \u6837\u6761\u57fa\u51fd\u6570\u65f6\uff0c\u6a2a\u5750\u6807\u9644\u4e0a\u7ed8\u5236\u7684\u8282\u70b9\u5e8f\u5217\u4e0b\u6807\u4e0e\u7ed8\u5236\u7684\u57fa\u51fd\u6570\u4e0b\u6807\u3002 Knowledge \\(Def\\) \uff08 \\(Cox-deBoor\\) \u9012\u63a8\u516c\u5f0f\uff09\uff1a\u7ed9\u5b9a\u53c2\u6570 \\(u\\) \u7684\u5b9a\u4e49\u57df\uff08\u672a\u58f0\u660e\u65f6\u9ed8\u8ba4\u4e3a\u89c4\u8303\u5b9a\u4e49\u57df \\(u\\in[0,1]\\) \uff09\u7684\u4e00\u4e2a\u5206\u5272 \\(a = u_0 \\le u_1 \\le \\cdots \\le u_k = b\\) \uff0c \\(U=\\{u_0, u_1, \\cdots, u_k\\}\\) \u79f0\u4e3a\u8282\u70b9\u5e8f\u5217\uff0c \\(u_i(i=0,1,\\cdots,k)\\) \u79f0\u4e3a\u8282\u70b9 \\((Knot)\\) \uff0c \\(n\\) \u6b21 \\(B\\) \u6837\u6761\u57fa\u51fd\u6570\u7684\u9012\u63a8\u516c\u5f0f\u5982\u4e0b \\[ \\begin{align} N_i^0(u) &= \\begin{cases} 1, \\quad &if \\quad u_i \\le u \\le u_{i+1} \\\\ 0, \\quad &else \\end{cases} \\\\\\\\ N_i^n(u) &= \\frac{u - u_i}{u_{i+n} - u_i} N_i^{n-1}(u) + \\frac{u_{i+n+1} - u}{u_{i+n+1} - u_{i+1}} N_{i+1}^{n-1}(u) \\\\\\ \u89c4\u5b9a \\frac{0}{0} &= 0 \\end{align} \\] \\(Def(Three\\ Types)\\) \uff1a \u5747\u5300\u8282\u70b9\u5e8f\u5217\uff08 \\(Uniform\\) \uff09\uff1a\u8282\u70b9\u5e8f\u5217 \\(U\\) \u4e2d\u7684\u8282\u70b9 \\(u_i\\) \u7b49\u8ddd\u5206\u5e03\uff0c\u5373 \\(\\Delta_i = u_{i+1} - u_i = Constant > 0\\) \u3002 \u51c6\u5747\u5300\u8282\u70b9\u5e8f\u5217\uff08 \\(Quasi-Uniform\\) \uff09\uff1a\u8282\u70b9\u5e8f\u5217 \\(U\\) \u4e2d\u7684\u4e24\u7aef\u8282\u70b9\u5177\u6709\u91cd\u590d\u5ea6 \\(n+1\\) \uff0c\u5373 \\(u_0 = u_1 = \\cdots = u_n, \\ u_{k - n} = u_{k - n + 1} = \\cdots = u_{k}\\) \uff1b\u5185\u8282\u70b9\u5177\u6709\u91cd\u590d\u5ea61\uff0c\u5373\u5747\u5300\u5206\u5e03\u3002 \u975e\u5747\u5300\u8282\u70b9\u5e8f\u5217\uff08 \\(Non-Uniform\\) \uff09\uff1a\u8282\u70b9\u5e8f\u5217 \\(U\\) \u4e2d\u7684\u8282\u70b9 \\(u_i\\) \u4efb\u610f\u5206\u5e03\uff0c\u5373\u4e24\u7aef\u8282\u70b9\u91cd\u590d\u5ea6 \\(\\le n+1\\) \u3001\u5185\u8282\u70b9\u91cd\u590d\u5ea6 \\(\\le n\\) \uff1b\u5bf9\u4e8e\u5f00\u66f2\u7ebf\uff0c\u4e24\u7aef\u8282\u70b9\u4e00\u822c\u53d6\u91cd\u590d\u5ea6\u4e3a \\(n+1\\) \u3002 \\(Thinking\\) \u601d\u8003\u70b9\uff1a\u5982\u4f55\u5c06\u9012\u5f52\u516c\u5f0f\u6c42\u89e3\u7528\u4ee3\u7801\u5b9e\u73b0\u2014\u2014\u5bf9\u7167\u6559\u6750\u4e0a\u7684\u4e0b\u6807\u89c2\u5bdf\uff0c\u533a\u5206\u4e3a\u4e0d\u540c\u7684\u60c5\u51b5\u3002 \u601d\u8003\u70b9\uff1a\u5982\u4f55\u5904\u7406\u8282\u70b9\u91cd\u590d\u60c5\u51b5\u2014\u2014\u5148\u4ea7\u751f\u4e24\u4fa7\u91cd\u590d\u8282\u70b9\uff0c\u518d\u751f\u6210\u5185\u90e8\u8282\u70b9\uff0c\u6700\u540e\u5408\u6210\u8282\u70b9\u5e8f\u5217\u3002 \u601d\u8003\u70b9\uff1a\u8282\u70b9\u91cd\u590d\u5f15\u8d77\u7684\u4e0b\u6807\u91cd\u53e0\u95ee\u9898\u2014\u2014\u81ea\u5b9a\u4e49\u4fee\u6539\u5904\u7406\u60c5\u51b5\u3002 Code Uniform # -*- coding: UTF-8 -*- \"\"\" @date-time: 8/1/2024 - 8:25 AM @author: gezq \"\"\" import numpy as np import pandas as pd from matplotlib import pyplot as plt import utils # To solve the problem of plt plt.rcParams[\"font.sans-serif\"] = [\"SimHei\"] plt.rcParams[\"axes.unicode_minus\"] = False def recursive_formula(n, i, U, u): \"\"\" Recursive formula of uniform b-spline basis function. :param n: the degree of the uniform b-spline basis function. :param i: the subscript in the sequence of knots. :param U: the sequence of knots. :param u: the values of drawing curve. :return: the result of recursive formula. \"\"\" if n == 0: return 1 if U[i] <= u <= U[i + 1] else 0 else: return ((u - U[i]) / (U[i + n] - U[i])) * recursive_formula(n - 1, i, U, u) + ( (U[i + n + 1] - u) / (U[i + n + 1] - U[i + 1])) * recursive_formula(n - 1, i + 1, U, u) def draw_b_spline(n, k): \"\"\" Draw B-spline basis functions :param n: the degree of the B-spline basis function. :param k: the number of the partition of u. :return: No return. \"\"\" # The sequence of knots U = np.linspace(0, 1, k + 1) # The values of drawing curve, we can add the num to make the curve more soft. u = np.linspace(0, 1, 300) for i in range(k - n): df_res = pd.DataFrame(columns=['x', 'y']) for uu in u: df_res.loc[len(df_res)] = [uu, recursive_formula(n, i, U, uu)] # There is not using df_res.plot() function, to avoid the legend is show. plt.plot(df_res['x'], df_res['y']) max_idx = df_res['y'].idxmax() plt.text(df_res['x'][max_idx], df_res['y'][max_idx], f'$N_{i}^{n}(u)$') utils.add_subscript_knots(U) plt.title(f'{n}-order {k + 1}-knots Uniform B-spline basis functions') plt.xlabel(\"u\") plt.ylabel(\"w\") plt.show() if __name__ == '__main__': n = int(input(\"Please input the degree of B-spline basis functions n=\")) k = int(input(\"Please input the number of partition of u (k should be greater than n ) k=\")) draw_b_spline(n, k) Quasi-Uniform # -*- coding: UTF-8 -*- \"\"\" @date-time: 8/1/2024 - 10:26 AM @author: gezq \"\"\" import numpy as np import pandas as pd from matplotlib import pyplot as plt import utils # To solve the problem of plt plt.rcParams[\"font.sans-serif\"] = [\"SimHei\"] plt.rcParams[\"axes.unicode_minus\"] = False def recursive_formula(n, i, U, u): \"\"\" Recursive formula of quasi-uniform b-spline basis function. :param n: the degree of the quasi-uniform b-spline basis function. :param i: the subscript in the sequence of knots. :param U: the sequence of knots. :param u: the values of drawing curve. :return: the result of recursive formula. \"\"\" if n == 0: return 1 if U[i] <= u <= U[i + 1] else 0 else: if U[i + n] - U[i] == 0 and U[i + n + 1] - U[i + 1] == 0: return 0 elif U[i + n] - U[i] == 0: return ((U[i + n + 1] - u) / (U[i + n + 1] - U[i + 1])) * recursive_formula(n - 1, i + 1, U, u) elif U[i + n + 1] - U[i + 1] == 0: return ((u - U[i]) / (U[i + n] - U[i])) * recursive_formula(n - 1, i, U, u) else: return ((u - U[i]) / (U[i + n] - U[i])) * recursive_formula(n - 1, i, U, u) + ( (U[i + n + 1] - u) / (U[i + n + 1] - U[i + 1])) * recursive_formula(n - 1, i + 1, U, u) def draw_b_spline(n, k): \"\"\" Draw B-spline basis functions :param n: the degree of the B-spline basis function. :param k: the number of the partition of u. :return: No return. \"\"\" # Create the sequence of knots of quasi-uniform. left_U = np.repeat(0.0, n) right_U = np.repeat(1.0, n) # Total knots is k\uff0csubtract the repeats of two sides\uff0cso the result is k - 2 * n + 1. mid_U = np.linspace(0, 1, k - 2 * n + 1) # The final sequence U = np.concatenate((left_U, mid_U, right_U)) # The values of drawing curve, we can add the num to make the curve more soft. u = np.linspace(0, 1, 100) for i in range(k - n): df_res = pd.DataFrame(columns=['x', 'y']) for uu in u: df_res.loc[len(df_res)] = [uu, recursive_formula(n, i, U, uu)] # There is not using df_res.plot() function, to avoid the legend is show. plt.plot(df_res['x'], df_res['y']) max_idx = df_res['y'].idxmax() plt.text(df_res['x'][max_idx], df_res['y'][max_idx], f'$N_{i}^{n}(u)$') utils.add_subscript_knots(U) plt.title(f'{n}-order {k + 1}-knots Quasi-Uniform B-spline basis functions') plt.xlabel(\"u\") plt.ylabel(\"w\") plt.show() if __name__ == '__main__': n = int(input(\"Please input the degree of B-spline basis functions n=\")) k = int(input(\"Please input the number of partition of u (k should be greater than 2n + 1 ) k=\")) draw_b_spline(n, k) Non-Uniform # -*- coding: UTF-8 -*- \"\"\" @date-time: 8/1/2024 - 10:59 AM @author: gezq \"\"\" import numpy as np import pandas as pd from matplotlib import pyplot as plt import utils # To solve the problem of plt plt.rcParams[\"font.sans-serif\"] = [\"SimHei\"] plt.rcParams[\"axes.unicode_minus\"] = False def recursive_formula(n, i, U, u): \"\"\" Recursive formula of non-uniform b-spline basis function. :param n: the degree of the non-uniform b-spline basis function. :param i: the subscript in the sequence of knots. :param U: the sequence of knots. :param u: the values of drawing curve. :return: the result of recursive formula. \"\"\" if n == 0: return 1 if U[i] <= u <= U[i + 1] else 0 else: if U[i + n] - U[i] == 0 and U[i + n + 1] - U[i + 1] == 0: return 0 elif U[i + n] - U[i] == 0: return ((U[i + n + 1] - u) / (U[i + n + 1] - U[i + 1])) * recursive_formula(n - 1, i + 1, U, u) elif U[i + n + 1] - U[i + 1] == 0: return ((u - U[i]) / (U[i + n] - U[i])) * recursive_formula(n - 1, i, U, u) else: return ((u - U[i]) / (U[i + n] - U[i])) * recursive_formula(n - 1, i, U, u) + ( (U[i + n + 1] - u) / (U[i + n + 1] - U[i + 1])) * recursive_formula(n - 1, i + 1, U, u) def draw_b_spline(n, k): \"\"\" Draw B-spline basis functions :param n: the degree of the B-spline basis function. :param k: the number of the partition of u. :return: No return. \"\"\" # Create the sequence of knots of quasi-uniform. left_U = np.repeat(0.0, n + 1) right_U = np.repeat(1.0, n + 1) # Total knots is k\uff0csubtract the repeats of two sides\uff0cso the result is k - 2*(n+1) + 1. # Take normal distribution to generate the inner knots and sort them. mid_U = np.sort(np.random.rand(k - 2 * (n + 1) + 1)) # The final sequence U = np.concatenate((left_U, mid_U, right_U)) # The values of drawing curve, we can add the num to make the curve more soft. u = np.linspace(0, 1, 100) for i in range(k - n): df_res = pd.DataFrame(columns=['x', 'y']) for uu in u: df_res.loc[len(df_res)] = [uu, recursive_formula(n, i, U, uu)] # There is not using df_res.plot() function, to avoid the legend is show. plt.plot(df_res['x'], df_res['y']) max_idx = df_res['y'].idxmax() plt.text(df_res['x'][max_idx], df_res['y'][max_idx], f'$N_{i}^{n}(u)$') utils.add_subscript_knots(U) plt.title(f'{n}-order {k + 1}-knots Non-Uniform B-spline basis functions') plt.xlabel(\"u\") plt.ylabel(\"w\") plt.show() if __name__ == '__main__': n = int(input(\"Please input the degree of B-spline basis functions n=\")) k = int(input(\"Please input the number of partition of u (k should be greater than 2n + 1 ) k=\")) draw_b_spline(n, k) Result Uniform Quasi-Uniform Non-Uniform n\u6b21B\u6837\u6761\u66f2\u7ebf\u7684\u7ed8\u5236 Description \u8f93\u5165 \\(n\\) \uff0c\u9f20\u6807\u8f93\u5165 \\(n+1\\) \u4e2a\u70b9\uff0c\u7ed8\u5236\u4e00\u6761 \\(B\\) \u6837\u6761\u66f2\u7ebf\uff0c\u540c\u65f6\u7ed8\u5236\u63a7\u5236\u591a\u8fb9\u5f62\u3002\u5747\u5300\u3001\u51c6\u5747\u5300\u3001\u975e\u5747\u5300\u7684\u60c5\u51b5\u90fd\u9700\u8981\u7ed8\u5236\u3002 \u70b9\u7528\u7a7a\u5fc3\u5706\u70b9\u8868\u793a\uff0c\u63a7\u5236\u591a\u8fb9\u5f62\u4e0e\u66f2\u7ebf\u7528\u4e0d\u540c\u989c\u8272\u533a\u5206\u3002 \u9f20\u6807\u8f93\u5165\u63a7\u5236\u9876\u70b9\uff0c\u6bcf\u4e2a\u70b9\u9644\u8fd1\u6807\u8bb0\u70b9\u5e8f\u5217\u53f7\uff08\u5373\u4e0b\u6807\uff09\u3002 Knowledge \\(Def\\) \uff08 \\(B\\) \u6837\u6761\u66f2\u7ebf\uff09\uff1a \\[ \\mathbf{C}(u) = \\sum_{i=0}^k N_i^n(u) \\mathbf{P}_i \\] \\(Thinking\\) Code Uniform # -*- coding: UTF-8 -*- \"\"\" @date-time: 8/1/2024 - 5:50 PM @author: gezq \"\"\" import numpy as np import pandas as pd from matplotlib import pyplot as plt import task0501_uniform import utils def calculate_b_spline_function(n, i, U): # The values of drawing curve, we can add the num to make the curve more soft. u = np.linspace(0, 1, 100) df_b_spline = pd.DataFrame(u, columns=['u']) for j in range(n + 1): single_list = [] for uu in u: single_list.append(task0501_uniform.recursive_formula(n, i + j, U, uu)) df_b_spline[j] = single_list return df_b_spline def calculate_b_spline(n, k, df_points): # The sequence of knots U = np.linspace(0, 1, n + k + 1) # utils.add_subscript_knots(U) df_result = pd.DataFrame() # Handle each segment of b-spline curve for i in range(k - n): df_b_spline = calculate_b_spline_function(n, i, U) # we can get the b-spline basis function by using the range of u df_basis = df_b_spline[df_b_spline['u'].apply(lambda x: U[i + n] < x < U[i + n + 1])].iloc[:, 1:].reset_index(drop=True) df_real = df_points.iloc[i: i + n + 1].reset_index(drop=True) df_result = pd.concat([df_result, df_basis.dot(df_real)]) return df_result def draw_b_spline(n, k, df_points): \"\"\" Draw B-spline curve. :param n: the degree of the B-spline curve. :param k: the number of the control points. :param df_points: the control points. :return: No return. \"\"\" df_result = calculate_b_spline(n, k, df_points) # Draw B-spline curve and control polygon. df_result.plot(x='x', y='y', label='B-spline curve', color='b', ax=plt.gca()) df_points.plot(x='x', y='y', label='Control polygon', color='r', marker='o', markerfacecolor='w', ax=plt.gca()) utils.add_subscript_control_points(df_points) plt.title(f'{n}-order {k}-control points Uniform B-spline basis functions') plt.xlabel(\"u\") plt.ylabel(\"w\") plt.show() if __name__ == '__main__': n = int(input(\"Please input the degree of B-spline curve n=\")) k = int(input(\"Please input the number of control points k=\")) draw_b_spline(n, k, utils.selection_point(k, f'{n}-order {k}-control points Uniform B-spline basis functions')) # case01 for test # n, k = 2, 6 # input_point_list = [[0.3, 0.2, 0.5, 0.9, 0.8, 0.6], [1, 3, 4, 3, 2, 1]] # case02 for test # n, k = 3, 6 # input_point_list = [[0.1, 0.3, 0.5, 0.7, 0.8, 0.9], [2, 2.2, 3, 3.1, 2.9, 2]] # draw_b_spline(n, k, pd.DataFrame({'x': input_point_list[0], 'y': input_point_list[1]})) Quasi-Uniform # -*- coding: UTF-8 -*- \"\"\" @date-time: 8/2/2024 - 11:11 AM @author: gezq \"\"\" import numpy as np import pandas as pd from matplotlib import pyplot as plt import task0502_quasi_uniform import utils def calculate_b_spline_function(n, i, U): # The values of drawing curve, we can add the num to make the curve more soft. u = np.linspace(0, 1, 100) df_b_spline = pd.DataFrame(u, columns=['u']) for j in range(n + 1): single_list = [] for uu in u: single_list.append(task0502_quasi_uniform.recursive_formula(n, i + j, U, uu)) df_b_spline[j] = single_list return df_b_spline def calculate_b_spline(n, k, df_points): # The sequence of knots # Create the sequence of knots of quasi-uniform. left_U = np.repeat(0.0, n) right_U = np.repeat(1.0, n) # n+k+1 - 2*n = k - n + 1 # Total knots is n+k+1\uff0csubtract the repeats of two sides\uff0cso the result is k - n + 1. mid_U = np.linspace(0, 1, k - n + 1) # The final sequence U = np.concatenate((left_U, mid_U, right_U)) # utils.add_subscript_knots(U) df_result = pd.DataFrame() # Handle each segment of b-spline curve for i in range(k - n): df_b_spline = calculate_b_spline_function(n, i, U) # we can get the b-spline basis function by using the range of u df_basis = df_b_spline[df_b_spline['u'].apply(lambda x: U[i + n] < x < U[i + n + 1])].iloc[:, 1:].reset_index(drop=True) df_real = df_points.iloc[i: i + n + 1].reset_index(drop=True) df_result = pd.concat([df_result, df_basis.dot(df_real)]) return df_result def draw_b_spline(n, k, df_points): \"\"\" Draw B-spline curve. :param n: the degree of the B-spline curve. :param k: the number of the control points. :param df_points: the control points. :return: No return. \"\"\" df_result = calculate_b_spline(n, k, df_points) # Draw B-spline curve and control polygon. df_result.plot(x='x', y='y', label='B-spline curve', color='b', ax=plt.gca()) df_points.plot(x='x', y='y', label='Control polygon', color='r', marker='o', markerfacecolor='w', ax=plt.gca()) utils.add_subscript_control_points(df_points) plt.title(f'{n}-order {k}-control points QuasiUniform B-spline basis functions') plt.xlabel(\"u\") plt.ylabel(\"w\") plt.show() if __name__ == '__main__': n = int(input(\"Please input the degree of B-spline curve n=\")) k = int(input(\"Please input the number of control points k=\")) draw_b_spline(n, k, utils.selection_point(k, f'{n}-order {k}-control points Quasi-Uniform B-spline basis functions')) # case01 for test # n, k = 2, 6 # input_point_list = [[0.2, 0.3, 0.5, 0.8, 0.9, 0.7], [1, 3, 4, 3, 2, 1]] # case02 for test # n, k = 3, 7 # input_point_list = [[0.1, 0.2, 0.4, 0.6, 0.5, 0.8, 0.9], [1, 3, 3.5, 3, 1, 0.5, 3]] # draw_b_spline(n, k, pd.DataFrame({'x': input_point_list[0], 'y': input_point_list[1]})) Non-Uniform # -*- coding: UTF-8 -*- \"\"\" @date-time: 8/2/2024 - 11:38 AM @author: gezq \"\"\" from math import sqrt import numpy as np import pandas as pd from matplotlib import pyplot as plt import task0502_quasi_uniform import utils def length_formula(i, n, k, len_list): \"\"\" \u8282\u70b9\u533a\u95f4\u957f\u5ea6\u516c\u5f0f :param i: \u5f53\u524d\u8282\u70b9\u5e8f\u53f7 :param k: B\u6837\u6761\u66f2\u7ebf\u7684\u6b21\u6570 :param len_list: \u76f8\u90bb\u63a7\u5236\u9876\u70b9\u957f\u5ea6\u7684\u5217\u8868 :return: \u76f8\u90bb\u8282\u70b9\u7684\u533a\u95f4\u957f\u5ea6 \"\"\" denominator = 0 for j in range(n + 1, k + 1): denominator += sum(len_list[j - n - 1: j - 1]) numerator = sum(len_list[i - n - 1: i - 1]) return round(numerator / denominator, 2) def calculate_length(k, df_points): \"\"\" \u4f9d\u6b21\u8ba1\u7b97\u76f8\u90bb\u4e24\u63a7\u5236\u8282\u70b9\u4e4b\u95f4\u7684\u957f\u5ea6 :param n: B\u6837\u6761\u66f2\u7ebf\u7684\u63a7\u5236\u9876\u70b9\u4e2a\u6570 :param point_list_x: \u9009\u70b9\u5750\u6807\u7684x\u7684\u5217\u8868 :param point_list_y: \u9009\u70b9\u5750\u6807\u7684y\u7684\u5217\u8868 :return: \u76f8\u90bb\u63a7\u5236\u9876\u70b9\u4e4b\u95f4\u7684\u957f\u5ea6\u7ec4\u6210\u7684\u5217\u8868 \"\"\" len_list = [] for i in range(1, k): len_list.append( round(sqrt(pow(df_points.iloc[i, 0] - df_points.iloc[i - 1, 0], 2) + pow(df_points.iloc[i, 1] - df_points.iloc[i - 1, 1], 2)), 2)) return len_list def generate_sequence_non(n, k, df_points): # \u6b21\u6570\u4e3ap\u3001\u63a7\u5236\u70b9\u4e2a\u6570\u4e3an + 1,\u3001\u8282\u70b9\u4e2a\u6570\u4e3am + 1\uff0c\u4e09\u8005\u5173\u7cfb\u6ee1\u8db3\uff1am= n + p + 1 left_U = np.repeat(0.0, n + 1) right_U = np.repeat(1.0, n + 1) # \u4f7f\u7528Hartley-Judd\u65b9\u6cd5\u8ba1\u7b97\u5185\u8282\u70b9 mid_U = [] len_list = calculate_length(k, df_points) for i in range(n + 1, k): # fix\uff1atemp\u9700\u8981\u5728\u6b64\u5904\u7f6e\u4e3a0 temp = 0 for j in range(n + 1, i + 1): temp += length_formula(j, n, k, len_list) mid_U.append(temp) # \u5408\u5e76\u6570\u7ec4 return np.concatenate((left_U, mid_U, right_U)) def calculate_b_spline_function(n, i, U): # The values of drawing curve, we can add the num to make the curve more soft. u = np.linspace(0, 1, 100) df_b_spline = pd.DataFrame(u, columns=['u']) for j in range(n + 1): single_list = [] for uu in u: single_list.append(task0502_quasi_uniform.recursive_formula(n, i + j, U, uu)) df_b_spline[j] = single_list return df_b_spline def calculate_b_spline(n, k, df_points): # The sequence of knots # Create the sequence of knots of quasi-uniform. # left_U = np.repeat(0.0, n) # right_U = np.repeat(1.0, n) # # n+k+1 - 2*n = k - n + 1 # # Total knots is n+k+1\uff0csubtract the repeats of two sides\uff0cso the result is k - n + 1. # mid_U = np.linspace(0, 1, k - n + 1) # # The final sequence # U = np.concatenate((left_U, mid_U, right_U)) U = generate_sequence_non(n, k, df_points) # utils.add_subscript_knots(U) df_result = pd.DataFrame() # Handle each segment of b-spline curve for i in range(k - n): df_b_spline = calculate_b_spline_function(n, i, U) # we can get the b-spline basis function by using the range of u df_basis = df_b_spline[df_b_spline['u'].apply(lambda x: U[i + n] < x < U[i + n + 1])].iloc[:, 1:].reset_index(drop=True) df_real = df_points.iloc[i: i + n + 1].reset_index(drop=True) df_result = pd.concat([df_result, df_basis.dot(df_real)]) return df_result def draw_b_spline(n, k, df_points): \"\"\" Draw B-spline curve. :param n: the degree of the B-spline curve. :param k: the number of the control points. :param df_points: the control points. :return: No return. \"\"\" df_result = calculate_b_spline(n, k, df_points) # Draw B-spline curve and control polygon. df_result.plot(x='x', y='y', label='B-spline curve', color='b', ax=plt.gca()) df_points.plot(x='x', y='y', label='Control polygon', color='r', marker='o', markerfacecolor='w', ax=plt.gca()) utils.add_subscript_control_points(df_points) plt.title(f'{n}-order {k}-control points QuasiUniform B-spline basis functions') plt.xlabel(\"u\") plt.ylabel(\"w\") plt.show() if __name__ == '__main__': # n = int(input(\"Please input the degree of B-spline curve n=\")) # k = int(input(\"Please input the number of control points k=\")) # draw_b_spline(n, k, # utils.selection_point(k, f'{n}-order {k}-control points Quasi-Uniform B-spline basis functions')) # case01 for test n, k = 3, 6 input_point_list = [[0.3, 0.1, 0.5, 0.5, 0.9, 0.7], [1, 3, 5, 5, 3, 1]] draw_b_spline(n, k, pd.DataFrame({'x': input_point_list[0], 'y': input_point_list[1]})) Result \u4e09\u6b21\u5747\u5300B\u6837\u6761\u66f2\u7ebf\u63d2\u503c Description Knowledge Code Result \u56db\u70b9\u63d2\u503c\u7ec6\u5206\u6cd5 Description Knowledge Code Result \u5e73\u9762\u591a\u8fb9\u5f62Wachspress\u5750\u6807\u7684\u8ba1\u7b97\u53ca\u5176\u7b49\u9ad8\u7ebf Description Knowledge Code Result \u5e73\u9762\u591a\u8fb9\u5f62\u4e2d\u503c\u5750\u6807\u7684\u8ba1\u7b97\u53ca\u5176\u7b49\u9ad8\u7ebf Description Knowledge Code Result Catmull-Clark\u7ec6\u5206\u66f2\u9762 Description Knowledge Code Result Loop\u7ec6\u5206\u66f2\u9762 Description Knowledge Code Result Butterfly\u7ec6\u5206\u66f2\u9762 Description Knowledge Code Result 3D\u4e2d\u503c\u5750\u6807\u7684\u7b49\u503c\u9762 Description Knowledge Code Result","title":"Pre-school Tasks"},{"location":"cagd/pre-school_tasks/#nbernstein","text":"","title":"n\u6b21Bernstein\u57fa\u51fd\u6570\u7684\u7ed8\u5236"},{"location":"cagd/pre-school_tasks/#description","text":"\u8f93\u5165 \\(n\\) \uff0c\u5728\u540c\u4e00\u4e2a\u56fe\u4e2d\u7ed8\u5236 \\(n+1\\) \u4e2a \\(Bernstein\\) \u57fa\u51fd\u6570\u7684\u56fe\u50cf","title":"Description"},{"location":"cagd/pre-school_tasks/#knowledge","text":"\\(Def\\) \uff08 \\(Bernstein\\) \u57fa\u51fd\u6570\uff09\uff1a \\(n\\) \u6b21 \\(Bernstein\\) \u57fa\u51fd\u6570\u4e3a \\(B_0^n(t), B_1^n(t),\\cdots,B_i^n(t),\\cdots,B_n^n(t)\\) \uff0c\u5b83\u4eec\u4f9d\u6b21\u4e3a\u4e8c\u6b21\u9879 \\([t+(1-t)]^n\\) \u5c55\u5f00\u540e\u7684\u5404\u9879\uff0c\u5176\u4e2d \\(B_i^n(t)\\) \u662f \\(Bernstein\\) \u591a\u9879\u5f0f\u3002 \\[ B_i^n(t) = \\begin{pmatrix} n \\\\ i \\end{pmatrix} (1-t)^{n-i} t^i, \\quad t\\in [0,1], \\quad i = 0, 1, \\cdots, n. \\] \\(Thinking\\) \uff1a \u7531\u8f93\u5165\u7684 \\(Bernstein\\) \u57fa\u51fd\u6570\u7684\u6b21\u6570 \\(n\\) \uff0c\u5229\u7528 \\(for\\) \u5faa\u73af\u4f9d\u6b21\u8ba1\u7b97\u5e76\u7ed8\u5236\u6bcf\u6761\u66f2\u7ebf \\(B_i^n(t),(i=0,1,\\cdots,n)\\) \u3002 \u5b9a\u4e49\u51fd\u6570\uff1a\u5b9e\u73b0 \\(Bernstein\\) \u57fa\u51fd\u6570\u7684\u5b9a\u4e49\u516c\u5f0f\uff0c\u5373\u7ed9\u5b9a\u81ea\u53d8\u91cf \\(t\\) \u8ba1\u7b97\u5bf9\u5e94\u7684\u51fd\u6570\u503c\u3002","title":"Knowledge"},{"location":"cagd/pre-school_tasks/#code","text":"# -*- coding: UTF-8 -*- \"\"\" @date-time: 7/28/2024 - 11:24 PM @author: gezq \"\"\" import numpy as np from matplotlib import pyplot as plt from math import factorial as fac # To solve the problem of plt plt.rcParams[\"font.sans-serif\"] = [\"SimHei\"] plt.rcParams[\"axes.unicode_minus\"] = False def bernstein(n, i, t): \"\"\" Calculate the values of Bernstein's function. :param n: the degree of the Bernstein's function. :param i: the order of the Bernstein's function. :param t: the array of self-variable of the Bernstein's function. :return: the values of Bernstein's function. \"\"\" return (fac(n) / (fac(i) * fac(n - i))) * pow(t, i) * pow(1 - t, n - i) def draw_bernstein(n): \"\"\" Draw the Bernstein's function. :param n: the degree of the Bernstein's function. :return: No return. \"\"\" t = np.linspace(0, 1) for i in range(n + 1): plt.plot(t, bernstein(n, i, t)) # Use the property of max value of Bernstein basis function plt.text(i / n, bernstein(n, i, i / n) * 1.02, f'$ B_{i}^{n} $') plt.title(f'{n}-order Bernstein basis functions') plt.show() if __name__ == '__main__': n = int(input(\"Please input the degree of Bernstein basis functions n=\")) draw_bernstein(n)","title":"Code"},{"location":"cagd/pre-school_tasks/#result","text":"","title":"Result"},{"location":"cagd/pre-school_tasks/#nbezier","text":"","title":"n\u6b21B\u00e9zier\u66f2\u7ebf\u7684\u7ed8\u5236"},{"location":"cagd/pre-school_tasks/#description_1","text":"\u8f93\u5165 \\(n\\) \uff0c\u9f20\u6807\u8f93\u5165 \\(n+1\\) \u4e2a\u70b9\uff0c\u7ed8\u5236\u4e00\u6761 \\(B\u00e9zier\\) \u66f2\u7ebf\uff0c\u540c\u65f6\u7ed8\u5236\u63a7\u5236\u591a\u8fb9\u5f62\u3002 \u70b9\u7528\u7a7a\u5fc3\u5706\u70b9\u8868\u793a\uff0c\u63a7\u5236\u591a\u8fb9\u5f62\u4e0e\u66f2\u7ebf\u7528\u4e0d\u540c\u989c\u8272\u533a\u5206\u3002 \u9f20\u6807\u8f93\u5165\u63a7\u5236\u9876\u70b9\uff0c\u6bcf\u4e2a\u70b9\u9644\u8fd1\u6807\u8bb0\u70b9\u5e8f\u5217\u53f7\uff08\u5373\u4e0b\u6807\uff09\u3002","title":"Description"},{"location":"cagd/pre-school_tasks/#knowledge_1","text":"\\(Def\\) \uff08 \\(B\u00e9zier\\) \u66f2\u7ebf\uff09\uff1a \\(n\\) \u6b21 \\(B\u00e9zier\\) \u66f2\u7ebf\u7684\u5b9a\u4e49\u5982\u4e0b\uff0c\u5176\u4e2d \\(P_i\\) \u4e3a\u63a7\u5236\u70b9\uff0c \\(B_i^n(t)\\) \u4e3a \\(Bernstein\\) \u57fa\u51fd\u6570\u3002 \\[ \\mathbf{C}(t) = \\sum_{i=0}^n \\mathbf{P}_i B_i^n(t), \\quad t \\in [0,1]. \\] \\(Thinking\\) \uff1a \u5bfc\u5165 task01 \u4e2d\u8ba1\u7b97 \\(B_i^n(t)\\) \u7684\u51fd\u6570\u3002 \u5b9a\u4e49\u51fd\u6570\uff1a\u8ba1\u7b97\u6240\u6709 \\(Bernstein\\) \u57fa\u51fd\u6570\u5728 \\(t\\in[0,1]\\) \u4e4b\u95f4\u7684\u6240\u6709\u503c\u3002 \u601d\u8003\u70b9\uff1a\u7531 \\(B\u00e9zier\\) \u66f2\u7ebf\u7684\u5b9a\u4e49\uff08 \\(Bernstein\\) \u57fa\u51fd\u6570\u4e0e\u63a7\u5236\u70b9\uff09\u8ba1\u7b97\u5bf9\u5e94\u7684\u51fd\u6570\u503c\u2014\u2014\u7c7b\u4f3c\u77e9\u9635\u76f8\u4e58\u7684\u601d\u60f3\u3002 \u5b9a\u4e49\u51fd\u6570\uff1a\u7ed8\u5236\u56fe\u5f62( \\(B\u00e9zier\\) \u66f2\u7ebf\u3001\u63a7\u5236\u591a\u8fb9\u5f62\u53ca\u63a7\u5236\u9876\u70b9)\u3002 \u601d\u8003\u70b9\uff1a\u591a\u4e2a \\(Bernstein\\) \u57fa\u51fd\u6570\u7684\u503c\u7684\u5b58\u653e\u5f62\u5f0f\uff0c\u53ca\u540e\u7eed\u5982\u4f55\u83b7\u53d6 \\(B\u00e9zier\\) \u66f2\u7ebf\u7684\u51fd\u6570\u503c\u2014\u2014 DataFrame \u3002 \u601d\u8003\u70b9\uff1a\u9f20\u6807\u9009\u70b9\u2014\u2014\u672a\u4f7f\u7528 figure.canvas.mpl_connect \u7ed1\u5b9a\u4e8b\u4ef6\uff0c\u800c\u91c7\u7528\u66f4\u7b80\u4fbf\u7684 ginput() \u51fd\u6570\u76f4\u63a5\u83b7\u53d6\u70b9\u7684\u5750\u6807\u3002 \u4e3a\u4fbf\u4e8e\u540e\u7eed\u4ee3\u7801\u4e2d import task02 \uff0c\u56e0\u6b64\u8c03\u6574\u51fd\u6570\u4e2d\u53d8\u91cf\u4ee5\u53c2\u6570\u5f62\u5f0f\u4f20\u9012\uff0c\u907f\u514d\u4f7f\u7528\u5168\u5c40\u53d8\u91cf\uff0c\u589e\u5f3a\u4e86\u4ee3\u7801\u7684\u53ef\u91cd\u7528\u6027\u3002","title":"Knowledge"},{"location":"cagd/pre-school_tasks/#code_1","text":"# -*- coding: UTF-8 -*- \"\"\" @date-time: 7/29/2024 - 8:36 AM @author: gezq \"\"\" import numpy as np import pandas as pd from matplotlib import pyplot as plt import task01 import utils def calculate_bernstein(n): \"\"\" Calculate Bernstein values :param n: the degree of the Bernstein's function. :return: the DataFrame of the values of Bernstein's function. \"\"\" t = np.linspace(0, 1) df_bernstein = pd.DataFrame() # The values of each Bernstein function as a column store in df_bernstein. for i in range(n + 1): df_bernstein[i] = task01.bernstein(n, i, t) return df_bernstein def calculate_bezier(n, df_points): \"\"\" Calculate Bezier values :param n: the degree of the B\u00e9zier curve. :param df_points: the control points. :return: the DataFrame of the values of B\u00e9zier curve. \"\"\" df_bernstein = calculate_bernstein(n) # Calculate the values of B\u00e9zier curve df_result = df_bernstein.dot(df_points) return df_result def draw_bezier(n, df_points): \"\"\" Draw the B\u00e9zier curve :param n: the degree of the B\u00e9zier curve. :param df_points: the control points. :return: No return. \"\"\" df_result = calculate_bezier(n, df_points) # Draw B\u00e9zier curve and control polygon. df_result.plot(x='x', y='y', label='B\u00e9zier curve', color='b', ax=plt.gca()) df_points.plot(x='x', y='y', label='Control polygon', color='r', marker='o', markerfacecolor='w', ax=plt.gca()) utils.add_text_subscript(df_points) plt.legend() plt.show() if __name__ == '__main__': n = int(input(\"Please input the degree of B\u00e9zier curve n=\")) draw_bezier(n, utils.selection_point(n + 1, f'{n}-order B\u00e9zier curve'))","title":"Code"},{"location":"cagd/pre-school_tasks/#result_1","text":"","title":"Result"},{"location":"cagd/pre-school_tasks/#nbezier_1","text":"","title":"n\u6b21B\u00e9zier\u66f2\u7ebf\u7684\u51e0\u4f55\u4f5c\u56fe\u6cd5"},{"location":"cagd/pre-school_tasks/#description_2","text":"\u8f93\u5165 \\(n\\) \uff0c\u8f93\u5165\u53d8\u91cf \\(t\\) \uff0c\u9f20\u6807\u8f93\u5165 \\(n+1\\) \u4e2a\u70b9\uff0c\u7ed8\u5236\u4e00\u6761 \\(B\u00e9zier\\) \u66f2\u7ebf\u7684\u63a7\u5236\u591a\u8fb9\u5f62\uff0c\u540c\u65f6\u7ed8\u5236\u51e0\u4f55\u4f5c\u56fe\u6cd5\u8fc7\u7a0b\u4e2d\u6bcf\u4e2a\u70b9\u3001\u6bcf\u6761\u7ebf\u6bb5\uff0c\u6700\u540e\u7ed8\u5236\u66f2\u7ebf\u4e0a\u53c2\u6570\u4e3a$t\uffe5\u7684\u70b9\uff0c\u7528\u4e0d\u540c\u989c\u8272\u4e0e\u5176\u4ed6\u70b9\u533a\u5206\u3002 \u9f20\u6807\u8f93\u5165\u63a7\u5236\u9876\u70b9\uff0c\u6bcf\u4e2a\u70b9\u9644\u8fd1\u6807\u8bb0\u70b9\u5e8f\u5217\u53f7\uff08\u5373\u4e0b\u6807\uff09\u3002","title":"Description"},{"location":"cagd/pre-school_tasks/#knowledge_2","text":"\\(Def\\) \uff08 \\(de\\ Casteljau\\) \u7b97\u6cd5\u9012\u63a8\u516c\u5f0f\uff09\uff1a\u5176\u4e2d \\(k\\) \u4e3a\u9012\u5f52\u8f6e\u6b21\u3002 \\[ \\mathbf P_i^k(t) = \\begin{cases} \\mathbf P_i, &k=0; \\quad i=0,1,\\cdots,n \\\\ (1 - t) \\mathbf P_{i}^{k-1}(t) + t\\mathbf P_{i+1}^{k-1}(t), \\quad &k=1,2,\\cdots,n;\\quad i=0,1,\\cdots,n - k. \\end{cases} \\] \\(Thinking\\) \u7ed8\u5236 \\(B\u00e9zier\\) \u66f2\u7ebf\u3001\u63a7\u5236\u591a\u8fb9\u5f62\u53ca\u63a7\u5236\u9876\u70b9\u4e0e task02 \u7c7b\u4f3c\u3002 \u601d\u8003\u70b9\uff1a\u9012\u63a8\u7b97\u6cd5\u7684\u5b9e\u73b0\u2014\u2014\u7531\u672c\u6b21\u63a7\u5236\u70b9\u8ba1\u7b97\u51fa\u4e0b\u4e00\u8f6e\u7684\u70b9\uff0c\u5c06\u672c\u6b21\u63a7\u5236\u70b9\u8986\u76d6\u540e\u518d\u7ed8\u5236\uff0c\u91cd\u590d \\(n\\) \u6b21\u6b64\u64cd\u4f5c\u3002","title":"Knowledge"},{"location":"cagd/pre-school_tasks/#code_2","text":"# -*- coding: UTF-8 -*- \"\"\" @date-time: 7/29/2024 - 11:32 AM @author: gezq \"\"\" from fractions import Fraction from matplotlib import pyplot as plt import task02 import utils def recursive_formula(df_points, i, t): \"\"\" deCasteljau recursive formula :param df_points: the control points of current time. :param i: the time index. :param t: the parameter value. :return: the result of recursive formula. \"\"\" return (1 - t) * df_points.iloc[i] + t * df_points.iloc[i + 1] def recursion(n, df_points, i, t): \"\"\" deCasteljau recursive algorithm :param n: the degree of the B\u00e9zier curve. :param df_points: the control points of current time. :param i: the time index. :param t: the parameter value. :return: the control points of next time. \"\"\" if i == 0: return df_points for j in range(n - i + 1): df_points.iloc[j] = recursive_formula(df_points, j, t) return df_points.iloc[:n - i + 1, :] def draw_bezier_geometry(n, df_points, t): \"\"\" Draw the B\u00e9zier curve of geometric processing. :param n: the degree of the B\u00e9zier curve. :param df_points: the control points. :param t: the parameter value. :return: No return. \"\"\" df_result = task02.calculate_bezier(n, df_points) # Unify the color of curve, 'k' is black. df_result.plot(x='x', y='y', label='B\u00e9zier curve', color='b', ax=plt.gca()) # Cycle n times for i in range(n + 1): df_points = recursion(n, df_points, i, t) df_points.plot(x='x', y='y', label=f'The {i} round', marker='o', markerfacecolor='w', ax=plt.gca()) utils.add_text_subscript_with_specify_superscript(df_points, i) plt.legend() plt.show() if __name__ == '__main__': n = int(input(\"Please input the degree of B\u00e9zier curve n=\")) # Import Fraction for handling the parameter t. t = Fraction(input(\"Please input the parameter t=\")) draw_bezier_geometry(n, utils.selection_point(n + 1, f'Geometric progressing of {n}-order B\u00e9zier curve (t={t})'), float(t))","title":"Code"},{"location":"cagd/pre-school_tasks/#result_2","text":"","title":"Result"},{"location":"cagd/pre-school_tasks/#bezier","text":"","title":"B\u00e9zier\u66f2\u7ebf\u7684\u63d2\u503c"},{"location":"cagd/pre-school_tasks/#description_3","text":"\u7ed9\u5b9a \\(n+1\\) \u4e2a\u70b9\uff0c\u8981\u6c42\u7b97\u51fa \\(n\\) \u6b21 \\(B\u00e9zier\\) \u66f2\u7ebf\u7684\u63a7\u5236\u9876\u70b9\uff0c\u4f7f\u5f97 \\(n+1\\) \u4e2a\u70b9\u5728 \\(n\\) \u6b21 \\(B\u00e9zier\\) \u66f2\u7ebf\u4e0a\u3002 \u9f20\u6807\u8f93\u5165\u63a7\u5236\u9876\u70b9\uff0c\u6bcf\u4e2a\u70b9\u9644\u8fd1\u6807\u8bb0\u70b9\u5e8f\u5217\u53f7\uff08\u5373\u4e0b\u6807\uff09\u3002","title":"Description"},{"location":"cagd/pre-school_tasks/#knowledge_3","text":"\\(Def\\) \uff08 \\(B\u00e9zier\\) \u66f2\u7ebf\u7684\u77e9\u9635\u5f62\u5f0f\uff09\uff1a \\(n\\) \u6b21 \\(B\u00e9zier\\) \u66f2\u7ebf\u7684\u77e9\u9635\u5f62\u5f0f\u5982\u4e0b\uff0c\u5176\u4e2d \\(P_i\\) \u4e3a\u63a7\u5236\u70b9\uff0c \\(B_i^n(t)\\) \u4e3a \\(Bernstein\\) \u57fa\u51fd\u6570\u3002 \\[ \\begin{align} \\mathbf{C}(t) &= \\sum_{i=0}^n \\mathbf{P}_i B_i^n(t), \\quad t \\in [0,1]. \\\\ &= \\begin{pmatrix} B_0^d(t) & B_1^d(t) & \\cdots & B_d^d(t) \\end{pmatrix} \\cdot \\begin{pmatrix} \\mathbf{P}_0 \\\\ \\mathbf{P}_1 \\\\ \\vdots \\\\ \\mathbf{P}_d \\end{pmatrix} \\end{align} \\] \u82e5\u7ed9\u5b9a\u4efb\u610f \\(n+1\\) \u4e2a\u70b9 \\(\\boldsymbol{v}_i(i=0,1,\\cdots,d)\\) \uff0c\u5373 \\(\\boldsymbol{v}_i = \\mathbf{C}(t_i)\\) \uff0c\u5219\u6709\u5982\u4e0b\u5f62\u5f0f\uff1a \\[ \\begin{align} \\begin{pmatrix} \\mathbf{C}(t_0) \\\\ \\mathbf{C}(t_1) \\\\ \\vdots \\\\ \\mathbf{C}(t_n) \\end{pmatrix} = \\begin{pmatrix} \\boldsymbol{v}_0 \\\\ \\boldsymbol{v}_1 \\\\ \\vdots \\\\ \\boldsymbol{v}_n \\end{pmatrix} &= \\begin{pmatrix} B_0^n(t_0) & B_1^n(t_0) & \\cdots & B_n^n(t_0) \\\\ B_0^n(t_1) & B_1^n(t_1) & \\cdots & B_n^n(t_1) \\\\ \\vdots & \\vdots & \\ddots & \\vdots \\\\ B_0^n(t_n) & B_1^n(t_n) & \\cdots & B_n^n(t_n) \\\\ \\end{pmatrix} \\cdot \\begin{pmatrix} \\mathbf{P}_0 \\\\ \\mathbf{P}_1 \\\\ \\vdots \\\\ \\mathbf{P}_n \\end{pmatrix} \\\\\\\\ \\begin{pmatrix} \\mathbf{P}_0 \\\\ \\mathbf{P}_1 \\\\ \\vdots \\\\ \\mathbf{P}_n \\end{pmatrix} &= {\\begin{pmatrix} B_0^n(t_0) & B_1^n(t_0) & \\cdots & B_n^n(t_0) \\\\ B_0^n(t_1) & B_1^n(t_1) & \\cdots & B_n^n(t_1) \\\\ \\vdots & \\vdots & \\ddots & \\vdots \\\\ B_0^n(t_n) & B_1^n(t_n) & \\cdots & B_n^n(t_n) \\\\ \\end{pmatrix}}^{-1} \\cdot \\begin{pmatrix} \\boldsymbol{v}_0 \\\\ \\boldsymbol{v}_1 \\\\ \\vdots \\\\ \\boldsymbol{v}_n \\end{pmatrix} \\end{align} \\] \u4e3a\u7b80\u4fbf\u8d77\u89c1\uff0c\u4e00\u822c\u53d6 \\(t_i = \\frac{i}{n}(i=0,1,\\cdots,n)\\) \uff0c\u5219\u53ef\u5f97\u5982\u4e0b\u5f62\u5f0f\uff1a \\[ \\begin{pmatrix} \\mathbf{P}_0 \\\\ \\mathbf{P}_1 \\\\ \\vdots \\\\ \\mathbf{P}_n \\end{pmatrix} = {\\begin{pmatrix} 1 & 0 & \\cdots & 0 \\\\ B_0^n(\\frac{1}{d}) & B_1^n(\\frac{1}{d}) & \\cdots & B_n^n(\\frac{1}{d}) \\\\ \\vdots & \\vdots & \\ddots & \\vdots \\\\ 0 & 0 & \\cdots & 1 \\\\ \\end{pmatrix}}^{-1} \\cdot \\begin{pmatrix} \\boldsymbol{v}_0 \\\\ \\boldsymbol{v}_1 \\\\ \\vdots \\\\ \\boldsymbol{v}_n \\end{pmatrix} \\] \u5c06\u4e0a\u8ff0\u77e9\u9635\u5f62\u5f0f\u5199\u4e3a\u7ebf\u6027\u65b9\u7a0b\u7ec4\u5f62\u5f0f\uff1a \\[ \\begin{cases} \\mathbf{P}_0 &= \\boldsymbol{v}_0 \\\\ \\mathbf{P}_n &= \\boldsymbol{v}_n \\\\ \\sum_{i=0}^{n} \\begin{pmatrix} n \\\\ i \\end{pmatrix} \\left( 1-\\frac{i}{n} \\right)^{n-i} \\left( \\frac{i}{n} \\right)^{i} \\mathbf{P}_j &= \\boldsymbol{v}_j,\\quad j=0,1,\\cdots,d-1. \\end{cases} \\] \u901a\u8fc7\u6c42\u89e3\u4e0a\u8ff0\u7ebf\u6027\u65b9\u7a0b\u7ec4\u4fbf\u53ef\u4ee5\u6c42\u51fa\u5bf9\u5e94 \\(n\\) \u6b21 \\(B\u00e9zier\\) \u66f2\u7ebf\u7684 \\(n+1\\) \u4e2a\u63a7\u5236\u9876\u70b9\u3002 \\(Thinking\\) \u7ed8\u5236 \\(B\u00e9zier\\) \u66f2\u7ebf\u3001\u63a7\u5236\u591a\u8fb9\u5f62\u53ca\u63a7\u5236\u9876\u70b9\u4e0e task02 , task03 \u7c7b\u4f3c\u3002 \u601d\u8003\u70b9\uff1a\u6c42\u89e3\u63a7\u5236\u9876\u70b9\u2014\u2014\u7531 \\(B\u00e9zier\\) \u66f2\u7ebf\u7684\u77e9\u9635\u5f62\u5f0f\u53ef\u7531\u7ed9\u5b9a\u7684 \\(n+1\\) \u4e2a\u70b9\u6c42\u89e3\u51fa \\(n+1\\) \u4e2a\u63a7\u5236\u9876\u70b9\u3002","title":"Knowledge"},{"location":"cagd/pre-school_tasks/#code_3","text":"# -*- coding: UTF-8 -*- \"\"\" @date-time: 7/29/2024 - 5:53 PM @author: gezq \"\"\" import numpy as np import pandas as pd from matplotlib import pyplot as plt import task02 import utils def calculate_control_points(n, df_points): \"\"\" Calculate control points from given points. :param n: the degree of the B\u00e9zier curve. :param df_points: the given points. :return: the control points. \"\"\" df_bernstein = task02.calculate_bernstein(n, np.linspace(0, 1, n + 1)) return pd.DataFrame(np.asmatrix(df_bernstein).I).dot(df_points) def draw_bezier_interpolation(n, df_points): \"\"\" Draw the B\u00e9zier curve of interpolation. :param n: the degree of the B\u00e9zier curve. :param df_points: the control points. :return: No return. \"\"\" df_control_points = calculate_control_points(n, df_points) df_result = task02.calculate_bezier(n, df_control_points) df_points.plot(x='x', y='y', label='Picked point', color='w', marker='o', markerfacecolor='k', ax=plt.gca()) df_result.plot(x='x', y='y', label='B\u00e9zier curve', color='b', ax=plt.gca()) df_control_points.plot(x='x', y='y', label='Control polygon', color='r', marker='o', markerfacecolor='w', ax=plt.gca()) utils.add_text_subscript(df_control_points) plt.xlabel(\"t\") plt.ylabel(\"u\") plt.xlim(xmin=0, xmax=1) plt.ylim(ymin=0, ymax=5) plt.legend() plt.show() if __name__ == '__main__': n = int(input(\"Please input the degree of Bernstein basis functions n=\")) draw_bezier_interpolation(n, utils.selection_point(n + 1, f'Interpolation of {n}-order B\u00e9zier curve'))","title":"Code"},{"location":"cagd/pre-school_tasks/#result_3","text":"","title":"Result"},{"location":"cagd/pre-school_tasks/#nb","text":"","title":"n\u6b21B\u6837\u6761\u57fa\u51fd\u6570\u7684\u7ed8\u5236"},{"location":"cagd/pre-school_tasks/#description_4","text":"\u8f93\u5165 \\(n\\) \uff0c\u5728\u540c\u4e00\u4e2a\u56fe\u4e2d\u7ed8\u5236 \\(n+1\\) \u4e2a \\(B\\) \u6837\u6761\u57fa\u51fd\u6570\u7684\u56fe\u50cf\u3002\u5747\u5300\u3001\u51c6\u5747\u5300\u3001\u975e\u5747\u5300\u7684\u60c5\u51b5\u90fd\u9700\u8981\u7ed8\u5236\u3002 \u7ed8\u5236 \\(B\\) \u6837\u6761\u57fa\u51fd\u6570\u65f6\uff0c\u6a2a\u5750\u6807\u9644\u4e0a\u7ed8\u5236\u7684\u8282\u70b9\u5e8f\u5217\u4e0b\u6807\u4e0e\u7ed8\u5236\u7684\u57fa\u51fd\u6570\u4e0b\u6807\u3002","title":"Description"},{"location":"cagd/pre-school_tasks/#knowledge_4","text":"\\(Def\\) \uff08 \\(Cox-deBoor\\) \u9012\u63a8\u516c\u5f0f\uff09\uff1a\u7ed9\u5b9a\u53c2\u6570 \\(u\\) \u7684\u5b9a\u4e49\u57df\uff08\u672a\u58f0\u660e\u65f6\u9ed8\u8ba4\u4e3a\u89c4\u8303\u5b9a\u4e49\u57df \\(u\\in[0,1]\\) \uff09\u7684\u4e00\u4e2a\u5206\u5272 \\(a = u_0 \\le u_1 \\le \\cdots \\le u_k = b\\) \uff0c \\(U=\\{u_0, u_1, \\cdots, u_k\\}\\) \u79f0\u4e3a\u8282\u70b9\u5e8f\u5217\uff0c \\(u_i(i=0,1,\\cdots,k)\\) \u79f0\u4e3a\u8282\u70b9 \\((Knot)\\) \uff0c \\(n\\) \u6b21 \\(B\\) \u6837\u6761\u57fa\u51fd\u6570\u7684\u9012\u63a8\u516c\u5f0f\u5982\u4e0b \\[ \\begin{align} N_i^0(u) &= \\begin{cases} 1, \\quad &if \\quad u_i \\le u \\le u_{i+1} \\\\ 0, \\quad &else \\end{cases} \\\\\\\\ N_i^n(u) &= \\frac{u - u_i}{u_{i+n} - u_i} N_i^{n-1}(u) + \\frac{u_{i+n+1} - u}{u_{i+n+1} - u_{i+1}} N_{i+1}^{n-1}(u) \\\\\\ \u89c4\u5b9a \\frac{0}{0} &= 0 \\end{align} \\] \\(Def(Three\\ Types)\\) \uff1a \u5747\u5300\u8282\u70b9\u5e8f\u5217\uff08 \\(Uniform\\) \uff09\uff1a\u8282\u70b9\u5e8f\u5217 \\(U\\) \u4e2d\u7684\u8282\u70b9 \\(u_i\\) \u7b49\u8ddd\u5206\u5e03\uff0c\u5373 \\(\\Delta_i = u_{i+1} - u_i = Constant > 0\\) \u3002 \u51c6\u5747\u5300\u8282\u70b9\u5e8f\u5217\uff08 \\(Quasi-Uniform\\) \uff09\uff1a\u8282\u70b9\u5e8f\u5217 \\(U\\) \u4e2d\u7684\u4e24\u7aef\u8282\u70b9\u5177\u6709\u91cd\u590d\u5ea6 \\(n+1\\) \uff0c\u5373 \\(u_0 = u_1 = \\cdots = u_n, \\ u_{k - n} = u_{k - n + 1} = \\cdots = u_{k}\\) \uff1b\u5185\u8282\u70b9\u5177\u6709\u91cd\u590d\u5ea61\uff0c\u5373\u5747\u5300\u5206\u5e03\u3002 \u975e\u5747\u5300\u8282\u70b9\u5e8f\u5217\uff08 \\(Non-Uniform\\) \uff09\uff1a\u8282\u70b9\u5e8f\u5217 \\(U\\) \u4e2d\u7684\u8282\u70b9 \\(u_i\\) \u4efb\u610f\u5206\u5e03\uff0c\u5373\u4e24\u7aef\u8282\u70b9\u91cd\u590d\u5ea6 \\(\\le n+1\\) \u3001\u5185\u8282\u70b9\u91cd\u590d\u5ea6 \\(\\le n\\) \uff1b\u5bf9\u4e8e\u5f00\u66f2\u7ebf\uff0c\u4e24\u7aef\u8282\u70b9\u4e00\u822c\u53d6\u91cd\u590d\u5ea6\u4e3a \\(n+1\\) \u3002 \\(Thinking\\) \u601d\u8003\u70b9\uff1a\u5982\u4f55\u5c06\u9012\u5f52\u516c\u5f0f\u6c42\u89e3\u7528\u4ee3\u7801\u5b9e\u73b0\u2014\u2014\u5bf9\u7167\u6559\u6750\u4e0a\u7684\u4e0b\u6807\u89c2\u5bdf\uff0c\u533a\u5206\u4e3a\u4e0d\u540c\u7684\u60c5\u51b5\u3002 \u601d\u8003\u70b9\uff1a\u5982\u4f55\u5904\u7406\u8282\u70b9\u91cd\u590d\u60c5\u51b5\u2014\u2014\u5148\u4ea7\u751f\u4e24\u4fa7\u91cd\u590d\u8282\u70b9\uff0c\u518d\u751f\u6210\u5185\u90e8\u8282\u70b9\uff0c\u6700\u540e\u5408\u6210\u8282\u70b9\u5e8f\u5217\u3002 \u601d\u8003\u70b9\uff1a\u8282\u70b9\u91cd\u590d\u5f15\u8d77\u7684\u4e0b\u6807\u91cd\u53e0\u95ee\u9898\u2014\u2014\u81ea\u5b9a\u4e49\u4fee\u6539\u5904\u7406\u60c5\u51b5\u3002","title":"Knowledge"},{"location":"cagd/pre-school_tasks/#code_4","text":"","title":"Code"},{"location":"cagd/pre-school_tasks/#uniform","text":"# -*- coding: UTF-8 -*- \"\"\" @date-time: 8/1/2024 - 8:25 AM @author: gezq \"\"\" import numpy as np import pandas as pd from matplotlib import pyplot as plt import utils # To solve the problem of plt plt.rcParams[\"font.sans-serif\"] = [\"SimHei\"] plt.rcParams[\"axes.unicode_minus\"] = False def recursive_formula(n, i, U, u): \"\"\" Recursive formula of uniform b-spline basis function. :param n: the degree of the uniform b-spline basis function. :param i: the subscript in the sequence of knots. :param U: the sequence of knots. :param u: the values of drawing curve. :return: the result of recursive formula. \"\"\" if n == 0: return 1 if U[i] <= u <= U[i + 1] else 0 else: return ((u - U[i]) / (U[i + n] - U[i])) * recursive_formula(n - 1, i, U, u) + ( (U[i + n + 1] - u) / (U[i + n + 1] - U[i + 1])) * recursive_formula(n - 1, i + 1, U, u) def draw_b_spline(n, k): \"\"\" Draw B-spline basis functions :param n: the degree of the B-spline basis function. :param k: the number of the partition of u. :return: No return. \"\"\" # The sequence of knots U = np.linspace(0, 1, k + 1) # The values of drawing curve, we can add the num to make the curve more soft. u = np.linspace(0, 1, 300) for i in range(k - n): df_res = pd.DataFrame(columns=['x', 'y']) for uu in u: df_res.loc[len(df_res)] = [uu, recursive_formula(n, i, U, uu)] # There is not using df_res.plot() function, to avoid the legend is show. plt.plot(df_res['x'], df_res['y']) max_idx = df_res['y'].idxmax() plt.text(df_res['x'][max_idx], df_res['y'][max_idx], f'$N_{i}^{n}(u)$') utils.add_subscript_knots(U) plt.title(f'{n}-order {k + 1}-knots Uniform B-spline basis functions') plt.xlabel(\"u\") plt.ylabel(\"w\") plt.show() if __name__ == '__main__': n = int(input(\"Please input the degree of B-spline basis functions n=\")) k = int(input(\"Please input the number of partition of u (k should be greater than n ) k=\")) draw_b_spline(n, k)","title":"Uniform"},{"location":"cagd/pre-school_tasks/#quasi-uniform","text":"# -*- coding: UTF-8 -*- \"\"\" @date-time: 8/1/2024 - 10:26 AM @author: gezq \"\"\" import numpy as np import pandas as pd from matplotlib import pyplot as plt import utils # To solve the problem of plt plt.rcParams[\"font.sans-serif\"] = [\"SimHei\"] plt.rcParams[\"axes.unicode_minus\"] = False def recursive_formula(n, i, U, u): \"\"\" Recursive formula of quasi-uniform b-spline basis function. :param n: the degree of the quasi-uniform b-spline basis function. :param i: the subscript in the sequence of knots. :param U: the sequence of knots. :param u: the values of drawing curve. :return: the result of recursive formula. \"\"\" if n == 0: return 1 if U[i] <= u <= U[i + 1] else 0 else: if U[i + n] - U[i] == 0 and U[i + n + 1] - U[i + 1] == 0: return 0 elif U[i + n] - U[i] == 0: return ((U[i + n + 1] - u) / (U[i + n + 1] - U[i + 1])) * recursive_formula(n - 1, i + 1, U, u) elif U[i + n + 1] - U[i + 1] == 0: return ((u - U[i]) / (U[i + n] - U[i])) * recursive_formula(n - 1, i, U, u) else: return ((u - U[i]) / (U[i + n] - U[i])) * recursive_formula(n - 1, i, U, u) + ( (U[i + n + 1] - u) / (U[i + n + 1] - U[i + 1])) * recursive_formula(n - 1, i + 1, U, u) def draw_b_spline(n, k): \"\"\" Draw B-spline basis functions :param n: the degree of the B-spline basis function. :param k: the number of the partition of u. :return: No return. \"\"\" # Create the sequence of knots of quasi-uniform. left_U = np.repeat(0.0, n) right_U = np.repeat(1.0, n) # Total knots is k\uff0csubtract the repeats of two sides\uff0cso the result is k - 2 * n + 1. mid_U = np.linspace(0, 1, k - 2 * n + 1) # The final sequence U = np.concatenate((left_U, mid_U, right_U)) # The values of drawing curve, we can add the num to make the curve more soft. u = np.linspace(0, 1, 100) for i in range(k - n): df_res = pd.DataFrame(columns=['x', 'y']) for uu in u: df_res.loc[len(df_res)] = [uu, recursive_formula(n, i, U, uu)] # There is not using df_res.plot() function, to avoid the legend is show. plt.plot(df_res['x'], df_res['y']) max_idx = df_res['y'].idxmax() plt.text(df_res['x'][max_idx], df_res['y'][max_idx], f'$N_{i}^{n}(u)$') utils.add_subscript_knots(U) plt.title(f'{n}-order {k + 1}-knots Quasi-Uniform B-spline basis functions') plt.xlabel(\"u\") plt.ylabel(\"w\") plt.show() if __name__ == '__main__': n = int(input(\"Please input the degree of B-spline basis functions n=\")) k = int(input(\"Please input the number of partition of u (k should be greater than 2n + 1 ) k=\")) draw_b_spline(n, k)","title":"Quasi-Uniform"},{"location":"cagd/pre-school_tasks/#non-uniform","text":"# -*- coding: UTF-8 -*- \"\"\" @date-time: 8/1/2024 - 10:59 AM @author: gezq \"\"\" import numpy as np import pandas as pd from matplotlib import pyplot as plt import utils # To solve the problem of plt plt.rcParams[\"font.sans-serif\"] = [\"SimHei\"] plt.rcParams[\"axes.unicode_minus\"] = False def recursive_formula(n, i, U, u): \"\"\" Recursive formula of non-uniform b-spline basis function. :param n: the degree of the non-uniform b-spline basis function. :param i: the subscript in the sequence of knots. :param U: the sequence of knots. :param u: the values of drawing curve. :return: the result of recursive formula. \"\"\" if n == 0: return 1 if U[i] <= u <= U[i + 1] else 0 else: if U[i + n] - U[i] == 0 and U[i + n + 1] - U[i + 1] == 0: return 0 elif U[i + n] - U[i] == 0: return ((U[i + n + 1] - u) / (U[i + n + 1] - U[i + 1])) * recursive_formula(n - 1, i + 1, U, u) elif U[i + n + 1] - U[i + 1] == 0: return ((u - U[i]) / (U[i + n] - U[i])) * recursive_formula(n - 1, i, U, u) else: return ((u - U[i]) / (U[i + n] - U[i])) * recursive_formula(n - 1, i, U, u) + ( (U[i + n + 1] - u) / (U[i + n + 1] - U[i + 1])) * recursive_formula(n - 1, i + 1, U, u) def draw_b_spline(n, k): \"\"\" Draw B-spline basis functions :param n: the degree of the B-spline basis function. :param k: the number of the partition of u. :return: No return. \"\"\" # Create the sequence of knots of quasi-uniform. left_U = np.repeat(0.0, n + 1) right_U = np.repeat(1.0, n + 1) # Total knots is k\uff0csubtract the repeats of two sides\uff0cso the result is k - 2*(n+1) + 1. # Take normal distribution to generate the inner knots and sort them. mid_U = np.sort(np.random.rand(k - 2 * (n + 1) + 1)) # The final sequence U = np.concatenate((left_U, mid_U, right_U)) # The values of drawing curve, we can add the num to make the curve more soft. u = np.linspace(0, 1, 100) for i in range(k - n): df_res = pd.DataFrame(columns=['x', 'y']) for uu in u: df_res.loc[len(df_res)] = [uu, recursive_formula(n, i, U, uu)] # There is not using df_res.plot() function, to avoid the legend is show. plt.plot(df_res['x'], df_res['y']) max_idx = df_res['y'].idxmax() plt.text(df_res['x'][max_idx], df_res['y'][max_idx], f'$N_{i}^{n}(u)$') utils.add_subscript_knots(U) plt.title(f'{n}-order {k + 1}-knots Non-Uniform B-spline basis functions') plt.xlabel(\"u\") plt.ylabel(\"w\") plt.show() if __name__ == '__main__': n = int(input(\"Please input the degree of B-spline basis functions n=\")) k = int(input(\"Please input the number of partition of u (k should be greater than 2n + 1 ) k=\")) draw_b_spline(n, k)","title":"Non-Uniform"},{"location":"cagd/pre-school_tasks/#result_4","text":"","title":"Result"},{"location":"cagd/pre-school_tasks/#uniform_1","text":"","title":"Uniform"},{"location":"cagd/pre-school_tasks/#quasi-uniform_1","text":"","title":"Quasi-Uniform"},{"location":"cagd/pre-school_tasks/#non-uniform_1","text":"","title":"Non-Uniform"},{"location":"cagd/pre-school_tasks/#nb_1","text":"","title":"n\u6b21B\u6837\u6761\u66f2\u7ebf\u7684\u7ed8\u5236"},{"location":"cagd/pre-school_tasks/#description_5","text":"\u8f93\u5165 \\(n\\) \uff0c\u9f20\u6807\u8f93\u5165 \\(n+1\\) \u4e2a\u70b9\uff0c\u7ed8\u5236\u4e00\u6761 \\(B\\) \u6837\u6761\u66f2\u7ebf\uff0c\u540c\u65f6\u7ed8\u5236\u63a7\u5236\u591a\u8fb9\u5f62\u3002\u5747\u5300\u3001\u51c6\u5747\u5300\u3001\u975e\u5747\u5300\u7684\u60c5\u51b5\u90fd\u9700\u8981\u7ed8\u5236\u3002 \u70b9\u7528\u7a7a\u5fc3\u5706\u70b9\u8868\u793a\uff0c\u63a7\u5236\u591a\u8fb9\u5f62\u4e0e\u66f2\u7ebf\u7528\u4e0d\u540c\u989c\u8272\u533a\u5206\u3002 \u9f20\u6807\u8f93\u5165\u63a7\u5236\u9876\u70b9\uff0c\u6bcf\u4e2a\u70b9\u9644\u8fd1\u6807\u8bb0\u70b9\u5e8f\u5217\u53f7\uff08\u5373\u4e0b\u6807\uff09\u3002","title":"Description"},{"location":"cagd/pre-school_tasks/#knowledge_5","text":"\\(Def\\) \uff08 \\(B\\) \u6837\u6761\u66f2\u7ebf\uff09\uff1a \\[ \\mathbf{C}(u) = \\sum_{i=0}^k N_i^n(u) \\mathbf{P}_i \\] \\(Thinking\\)","title":"Knowledge"},{"location":"cagd/pre-school_tasks/#code_5","text":"","title":"Code"},{"location":"cagd/pre-school_tasks/#uniform_2","text":"# -*- coding: UTF-8 -*- \"\"\" @date-time: 8/1/2024 - 5:50 PM @author: gezq \"\"\" import numpy as np import pandas as pd from matplotlib import pyplot as plt import task0501_uniform import utils def calculate_b_spline_function(n, i, U): # The values of drawing curve, we can add the num to make the curve more soft. u = np.linspace(0, 1, 100) df_b_spline = pd.DataFrame(u, columns=['u']) for j in range(n + 1): single_list = [] for uu in u: single_list.append(task0501_uniform.recursive_formula(n, i + j, U, uu)) df_b_spline[j] = single_list return df_b_spline def calculate_b_spline(n, k, df_points): # The sequence of knots U = np.linspace(0, 1, n + k + 1) # utils.add_subscript_knots(U) df_result = pd.DataFrame() # Handle each segment of b-spline curve for i in range(k - n): df_b_spline = calculate_b_spline_function(n, i, U) # we can get the b-spline basis function by using the range of u df_basis = df_b_spline[df_b_spline['u'].apply(lambda x: U[i + n] < x < U[i + n + 1])].iloc[:, 1:].reset_index(drop=True) df_real = df_points.iloc[i: i + n + 1].reset_index(drop=True) df_result = pd.concat([df_result, df_basis.dot(df_real)]) return df_result def draw_b_spline(n, k, df_points): \"\"\" Draw B-spline curve. :param n: the degree of the B-spline curve. :param k: the number of the control points. :param df_points: the control points. :return: No return. \"\"\" df_result = calculate_b_spline(n, k, df_points) # Draw B-spline curve and control polygon. df_result.plot(x='x', y='y', label='B-spline curve', color='b', ax=plt.gca()) df_points.plot(x='x', y='y', label='Control polygon', color='r', marker='o', markerfacecolor='w', ax=plt.gca()) utils.add_subscript_control_points(df_points) plt.title(f'{n}-order {k}-control points Uniform B-spline basis functions') plt.xlabel(\"u\") plt.ylabel(\"w\") plt.show() if __name__ == '__main__': n = int(input(\"Please input the degree of B-spline curve n=\")) k = int(input(\"Please input the number of control points k=\")) draw_b_spline(n, k, utils.selection_point(k, f'{n}-order {k}-control points Uniform B-spline basis functions')) # case01 for test # n, k = 2, 6 # input_point_list = [[0.3, 0.2, 0.5, 0.9, 0.8, 0.6], [1, 3, 4, 3, 2, 1]] # case02 for test # n, k = 3, 6 # input_point_list = [[0.1, 0.3, 0.5, 0.7, 0.8, 0.9], [2, 2.2, 3, 3.1, 2.9, 2]] # draw_b_spline(n, k, pd.DataFrame({'x': input_point_list[0], 'y': input_point_list[1]}))","title":"Uniform"},{"location":"cagd/pre-school_tasks/#quasi-uniform_2","text":"# -*- coding: UTF-8 -*- \"\"\" @date-time: 8/2/2024 - 11:11 AM @author: gezq \"\"\" import numpy as np import pandas as pd from matplotlib import pyplot as plt import task0502_quasi_uniform import utils def calculate_b_spline_function(n, i, U): # The values of drawing curve, we can add the num to make the curve more soft. u = np.linspace(0, 1, 100) df_b_spline = pd.DataFrame(u, columns=['u']) for j in range(n + 1): single_list = [] for uu in u: single_list.append(task0502_quasi_uniform.recursive_formula(n, i + j, U, uu)) df_b_spline[j] = single_list return df_b_spline def calculate_b_spline(n, k, df_points): # The sequence of knots # Create the sequence of knots of quasi-uniform. left_U = np.repeat(0.0, n) right_U = np.repeat(1.0, n) # n+k+1 - 2*n = k - n + 1 # Total knots is n+k+1\uff0csubtract the repeats of two sides\uff0cso the result is k - n + 1. mid_U = np.linspace(0, 1, k - n + 1) # The final sequence U = np.concatenate((left_U, mid_U, right_U)) # utils.add_subscript_knots(U) df_result = pd.DataFrame() # Handle each segment of b-spline curve for i in range(k - n): df_b_spline = calculate_b_spline_function(n, i, U) # we can get the b-spline basis function by using the range of u df_basis = df_b_spline[df_b_spline['u'].apply(lambda x: U[i + n] < x < U[i + n + 1])].iloc[:, 1:].reset_index(drop=True) df_real = df_points.iloc[i: i + n + 1].reset_index(drop=True) df_result = pd.concat([df_result, df_basis.dot(df_real)]) return df_result def draw_b_spline(n, k, df_points): \"\"\" Draw B-spline curve. :param n: the degree of the B-spline curve. :param k: the number of the control points. :param df_points: the control points. :return: No return. \"\"\" df_result = calculate_b_spline(n, k, df_points) # Draw B-spline curve and control polygon. df_result.plot(x='x', y='y', label='B-spline curve', color='b', ax=plt.gca()) df_points.plot(x='x', y='y', label='Control polygon', color='r', marker='o', markerfacecolor='w', ax=plt.gca()) utils.add_subscript_control_points(df_points) plt.title(f'{n}-order {k}-control points QuasiUniform B-spline basis functions') plt.xlabel(\"u\") plt.ylabel(\"w\") plt.show() if __name__ == '__main__': n = int(input(\"Please input the degree of B-spline curve n=\")) k = int(input(\"Please input the number of control points k=\")) draw_b_spline(n, k, utils.selection_point(k, f'{n}-order {k}-control points Quasi-Uniform B-spline basis functions')) # case01 for test # n, k = 2, 6 # input_point_list = [[0.2, 0.3, 0.5, 0.8, 0.9, 0.7], [1, 3, 4, 3, 2, 1]] # case02 for test # n, k = 3, 7 # input_point_list = [[0.1, 0.2, 0.4, 0.6, 0.5, 0.8, 0.9], [1, 3, 3.5, 3, 1, 0.5, 3]] # draw_b_spline(n, k, pd.DataFrame({'x': input_point_list[0], 'y': input_point_list[1]}))","title":"Quasi-Uniform"},{"location":"cagd/pre-school_tasks/#non-uniform_2","text":"# -*- coding: UTF-8 -*- \"\"\" @date-time: 8/2/2024 - 11:38 AM @author: gezq \"\"\" from math import sqrt import numpy as np import pandas as pd from matplotlib import pyplot as plt import task0502_quasi_uniform import utils def length_formula(i, n, k, len_list): \"\"\" \u8282\u70b9\u533a\u95f4\u957f\u5ea6\u516c\u5f0f :param i: \u5f53\u524d\u8282\u70b9\u5e8f\u53f7 :param k: B\u6837\u6761\u66f2\u7ebf\u7684\u6b21\u6570 :param len_list: \u76f8\u90bb\u63a7\u5236\u9876\u70b9\u957f\u5ea6\u7684\u5217\u8868 :return: \u76f8\u90bb\u8282\u70b9\u7684\u533a\u95f4\u957f\u5ea6 \"\"\" denominator = 0 for j in range(n + 1, k + 1): denominator += sum(len_list[j - n - 1: j - 1]) numerator = sum(len_list[i - n - 1: i - 1]) return round(numerator / denominator, 2) def calculate_length(k, df_points): \"\"\" \u4f9d\u6b21\u8ba1\u7b97\u76f8\u90bb\u4e24\u63a7\u5236\u8282\u70b9\u4e4b\u95f4\u7684\u957f\u5ea6 :param n: B\u6837\u6761\u66f2\u7ebf\u7684\u63a7\u5236\u9876\u70b9\u4e2a\u6570 :param point_list_x: \u9009\u70b9\u5750\u6807\u7684x\u7684\u5217\u8868 :param point_list_y: \u9009\u70b9\u5750\u6807\u7684y\u7684\u5217\u8868 :return: \u76f8\u90bb\u63a7\u5236\u9876\u70b9\u4e4b\u95f4\u7684\u957f\u5ea6\u7ec4\u6210\u7684\u5217\u8868 \"\"\" len_list = [] for i in range(1, k): len_list.append( round(sqrt(pow(df_points.iloc[i, 0] - df_points.iloc[i - 1, 0], 2) + pow(df_points.iloc[i, 1] - df_points.iloc[i - 1, 1], 2)), 2)) return len_list def generate_sequence_non(n, k, df_points): # \u6b21\u6570\u4e3ap\u3001\u63a7\u5236\u70b9\u4e2a\u6570\u4e3an + 1,\u3001\u8282\u70b9\u4e2a\u6570\u4e3am + 1\uff0c\u4e09\u8005\u5173\u7cfb\u6ee1\u8db3\uff1am= n + p + 1 left_U = np.repeat(0.0, n + 1) right_U = np.repeat(1.0, n + 1) # \u4f7f\u7528Hartley-Judd\u65b9\u6cd5\u8ba1\u7b97\u5185\u8282\u70b9 mid_U = [] len_list = calculate_length(k, df_points) for i in range(n + 1, k): # fix\uff1atemp\u9700\u8981\u5728\u6b64\u5904\u7f6e\u4e3a0 temp = 0 for j in range(n + 1, i + 1): temp += length_formula(j, n, k, len_list) mid_U.append(temp) # \u5408\u5e76\u6570\u7ec4 return np.concatenate((left_U, mid_U, right_U)) def calculate_b_spline_function(n, i, U): # The values of drawing curve, we can add the num to make the curve more soft. u = np.linspace(0, 1, 100) df_b_spline = pd.DataFrame(u, columns=['u']) for j in range(n + 1): single_list = [] for uu in u: single_list.append(task0502_quasi_uniform.recursive_formula(n, i + j, U, uu)) df_b_spline[j] = single_list return df_b_spline def calculate_b_spline(n, k, df_points): # The sequence of knots # Create the sequence of knots of quasi-uniform. # left_U = np.repeat(0.0, n) # right_U = np.repeat(1.0, n) # # n+k+1 - 2*n = k - n + 1 # # Total knots is n+k+1\uff0csubtract the repeats of two sides\uff0cso the result is k - n + 1. # mid_U = np.linspace(0, 1, k - n + 1) # # The final sequence # U = np.concatenate((left_U, mid_U, right_U)) U = generate_sequence_non(n, k, df_points) # utils.add_subscript_knots(U) df_result = pd.DataFrame() # Handle each segment of b-spline curve for i in range(k - n): df_b_spline = calculate_b_spline_function(n, i, U) # we can get the b-spline basis function by using the range of u df_basis = df_b_spline[df_b_spline['u'].apply(lambda x: U[i + n] < x < U[i + n + 1])].iloc[:, 1:].reset_index(drop=True) df_real = df_points.iloc[i: i + n + 1].reset_index(drop=True) df_result = pd.concat([df_result, df_basis.dot(df_real)]) return df_result def draw_b_spline(n, k, df_points): \"\"\" Draw B-spline curve. :param n: the degree of the B-spline curve. :param k: the number of the control points. :param df_points: the control points. :return: No return. \"\"\" df_result = calculate_b_spline(n, k, df_points) # Draw B-spline curve and control polygon. df_result.plot(x='x', y='y', label='B-spline curve', color='b', ax=plt.gca()) df_points.plot(x='x', y='y', label='Control polygon', color='r', marker='o', markerfacecolor='w', ax=plt.gca()) utils.add_subscript_control_points(df_points) plt.title(f'{n}-order {k}-control points QuasiUniform B-spline basis functions') plt.xlabel(\"u\") plt.ylabel(\"w\") plt.show() if __name__ == '__main__': # n = int(input(\"Please input the degree of B-spline curve n=\")) # k = int(input(\"Please input the number of control points k=\")) # draw_b_spline(n, k, # utils.selection_point(k, f'{n}-order {k}-control points Quasi-Uniform B-spline basis functions')) # case01 for test n, k = 3, 6 input_point_list = [[0.3, 0.1, 0.5, 0.5, 0.9, 0.7], [1, 3, 5, 5, 3, 1]] draw_b_spline(n, k, pd.DataFrame({'x': input_point_list[0], 'y': input_point_list[1]}))","title":"Non-Uniform"},{"location":"cagd/pre-school_tasks/#result_5","text":"","title":"Result"},{"location":"cagd/pre-school_tasks/#b","text":"","title":"\u4e09\u6b21\u5747\u5300B\u6837\u6761\u66f2\u7ebf\u63d2\u503c"},{"location":"cagd/pre-school_tasks/#description_6","text":"","title":"Description"},{"location":"cagd/pre-school_tasks/#knowledge_6","text":"","title":"Knowledge"},{"location":"cagd/pre-school_tasks/#code_6","text":"","title":"Code"},{"location":"cagd/pre-school_tasks/#result_6","text":"","title":"Result"},{"location":"cagd/pre-school_tasks/#_1","text":"","title":"\u56db\u70b9\u63d2\u503c\u7ec6\u5206\u6cd5"},{"location":"cagd/pre-school_tasks/#description_7","text":"","title":"Description"},{"location":"cagd/pre-school_tasks/#knowledge_7","text":"","title":"Knowledge"},{"location":"cagd/pre-school_tasks/#code_7","text":"","title":"Code"},{"location":"cagd/pre-school_tasks/#result_7","text":"","title":"Result"},{"location":"cagd/pre-school_tasks/#wachspress","text":"","title":"\u5e73\u9762\u591a\u8fb9\u5f62Wachspress\u5750\u6807\u7684\u8ba1\u7b97\u53ca\u5176\u7b49\u9ad8\u7ebf"},{"location":"cagd/pre-school_tasks/#description_8","text":"","title":"Description"},{"location":"cagd/pre-school_tasks/#knowledge_8","text":"","title":"Knowledge"},{"location":"cagd/pre-school_tasks/#code_8","text":"","title":"Code"},{"location":"cagd/pre-school_tasks/#result_8","text":"","title":"Result"},{"location":"cagd/pre-school_tasks/#_2","text":"","title":"\u5e73\u9762\u591a\u8fb9\u5f62\u4e2d\u503c\u5750\u6807\u7684\u8ba1\u7b97\u53ca\u5176\u7b49\u9ad8\u7ebf"},{"location":"cagd/pre-school_tasks/#description_9","text":"","title":"Description"},{"location":"cagd/pre-school_tasks/#knowledge_9","text":"","title":"Knowledge"},{"location":"cagd/pre-school_tasks/#code_9","text":"","title":"Code"},{"location":"cagd/pre-school_tasks/#result_9","text":"","title":"Result"},{"location":"cagd/pre-school_tasks/#catmull-clark","text":"","title":"Catmull-Clark\u7ec6\u5206\u66f2\u9762"},{"location":"cagd/pre-school_tasks/#description_10","text":"","title":"Description"},{"location":"cagd/pre-school_tasks/#knowledge_10","text":"","title":"Knowledge"},{"location":"cagd/pre-school_tasks/#code_10","text":"","title":"Code"},{"location":"cagd/pre-school_tasks/#result_10","text":"","title":"Result"},{"location":"cagd/pre-school_tasks/#loop","text":"","title":"Loop\u7ec6\u5206\u66f2\u9762"},{"location":"cagd/pre-school_tasks/#description_11","text":"","title":"Description"},{"location":"cagd/pre-school_tasks/#knowledge_11","text":"","title":"Knowledge"},{"location":"cagd/pre-school_tasks/#code_11","text":"","title":"Code"},{"location":"cagd/pre-school_tasks/#result_11","text":"","title":"Result"},{"location":"cagd/pre-school_tasks/#butterfly","text":"","title":"Butterfly\u7ec6\u5206\u66f2\u9762"},{"location":"cagd/pre-school_tasks/#description_12","text":"","title":"Description"},{"location":"cagd/pre-school_tasks/#knowledge_12","text":"","title":"Knowledge"},{"location":"cagd/pre-school_tasks/#code_12","text":"","title":"Code"},{"location":"cagd/pre-school_tasks/#result_12","text":"","title":"Result"},{"location":"cagd/pre-school_tasks/#3d","text":"","title":"3D\u4e2d\u503c\u5750\u6807\u7684\u7b49\u503c\u9762"},{"location":"cagd/pre-school_tasks/#description_13","text":"","title":"Description"},{"location":"cagd/pre-school_tasks/#knowledge_13","text":"","title":"Knowledge"},{"location":"cagd/pre-school_tasks/#code_13","text":"","title":"Code"},{"location":"cagd/pre-school_tasks/#result_13","text":"","title":"Result"},{"location":"cpp/libigl/","text":"\u5b89\u88c5MinGW\u548cCmake msvc x86_64\u7248\u672cMinGW \u4e0b\u8f7d\u540e\u89e3\u538b\uff0c\u5c06mingw64\u653e\u7f6e\u5230\u65b0\u76ee\u5f55\u3002 \u5728\u73af\u5883\u53d8\u91cfPATH\u4e2d\u6dfb\u52a0mingw64\u7684\u8def\u5f84\uff0c\u9700\u8981\u7cbe\u786e\u5230\u5176\u4e2d\u7684bin\u5b50\u76ee\u5f55\uff08\u5982D:\\Cpp\\mingw64\\bin\uff09 Download CMake \u4e0b\u8f7d\u540e\u76f4\u63a5\u5b89\u88c5\uff0c\u6709\u6dfb\u52a0\u5230\u73af\u5883\u53d8\u91cf\u65f6\u52fe\u9009\u5373\u53ef\uff0c\u5426\u5219\u4e5f\u9700\u8981\u540c\u4e0a\u8fdb\u884c\u914d\u7f6e\u3002 libigl example project libigl/libigl-example-project: A blank project example showing how to use libigl and cmake. (github.com) \u9996\u5148clone\u8be5\u9879\u76ee git clone https://github.com/libigl/libigl-example-project.git \u53ef\u4ee5\u6309\u7167\u5b98\u7f51\u4e2d\u6240\u8ff0\u8fdb\u884c\u64cd\u4f5c\uff0c\u4f46\u6b64\u5904\u4e0d\u91c7\u7528 mkdir build cd build cmake .. make \u5c06\u8be5\u9879\u76ee\u7528VSCode\u6253\u5f00\uff0c\u8fd0\u884c\u4e0b\u8ff0\u547d\u4ee4 cmake -B build \u70b9\u51fb\u751f\u6210\u8be5\u9879\u76ee\uff0c\u9009\u62e9\u6253\u5f00\u751f\u6210\u7684example.exe\u5373\u53ef libigl\u5b98\u7f51\uff1a libigl","title":"libigl"},{"location":"cpp/libigl/#mingwcmake","text":"msvc x86_64\u7248\u672cMinGW \u4e0b\u8f7d\u540e\u89e3\u538b\uff0c\u5c06mingw64\u653e\u7f6e\u5230\u65b0\u76ee\u5f55\u3002 \u5728\u73af\u5883\u53d8\u91cfPATH\u4e2d\u6dfb\u52a0mingw64\u7684\u8def\u5f84\uff0c\u9700\u8981\u7cbe\u786e\u5230\u5176\u4e2d\u7684bin\u5b50\u76ee\u5f55\uff08\u5982D:\\Cpp\\mingw64\\bin\uff09 Download CMake \u4e0b\u8f7d\u540e\u76f4\u63a5\u5b89\u88c5\uff0c\u6709\u6dfb\u52a0\u5230\u73af\u5883\u53d8\u91cf\u65f6\u52fe\u9009\u5373\u53ef\uff0c\u5426\u5219\u4e5f\u9700\u8981\u540c\u4e0a\u8fdb\u884c\u914d\u7f6e\u3002","title":"\u5b89\u88c5MinGW\u548cCmake"},{"location":"cpp/libigl/#libigl-example-project","text":"libigl/libigl-example-project: A blank project example showing how to use libigl and cmake. (github.com) \u9996\u5148clone\u8be5\u9879\u76ee git clone https://github.com/libigl/libigl-example-project.git \u53ef\u4ee5\u6309\u7167\u5b98\u7f51\u4e2d\u6240\u8ff0\u8fdb\u884c\u64cd\u4f5c\uff0c\u4f46\u6b64\u5904\u4e0d\u91c7\u7528 mkdir build cd build cmake .. make \u5c06\u8be5\u9879\u76ee\u7528VSCode\u6253\u5f00\uff0c\u8fd0\u884c\u4e0b\u8ff0\u547d\u4ee4 cmake -B build \u70b9\u51fb\u751f\u6210\u8be5\u9879\u76ee\uff0c\u9009\u62e9\u6253\u5f00\u751f\u6210\u7684example.exe\u5373\u53ef libigl\u5b98\u7f51\uff1a libigl","title":"libigl example project"},{"location":"python/numpy/","text":"","title":"numpy"},{"location":"software/git/","text":"\u5b89\u88c5 Git - Downloads (git-scm.com) \u7565.........\uff08\u66f4\u6539\u5b89\u88c5\u4f4d\u7f6e\u3001\u52fe\u9009\u6dfb\u52a0\u5230Path\u73af\u5883\u53d8\u91cf\uff0c\u4e4b\u540e\u4e00\u76f4next\u5373\u53ef\uff09\u3002 \u6d4b\u8bd5 \u6253\u5f00cmd\u7a97\u53e3\u6216PowerShell\u7a97\u53e3\uff0c\u8f93\u5165\u4e0b\u9762\u8bed\u53e5\u770b\u662f\u5426\u6b63\u786e\u663e\u793aGit\u7684\u7248\u672c\u3002 git --version \u82e5\u663e\u793aGit\u4e0d\u662f\u547d\u4ee4\uff0c\u5219\u5c1d\u8bd5\u5728\u73af\u5883\u53d8\u91cfPATH\u4e2d\u6dfb\u52a0Git\u7684\u5b89\u88c5\u76ee\u5f55\u4e0b\u7684bin\u5b50\u76ee\u5f55\uff08\u5982D:\\Git\\bin\uff09\u3002 \u914d\u7f6e \u6253\u5f00cmd\u7a97\u53e3\u6216PowerShell\u7a97\u53e3\uff0c\u8f93\u5165\u4e0b\u9762\u8bed\u53e5\u8bbe\u7f6eGit\u7684user\u76f8\u5173\u4fe1\u606f\u3002 git config --global user.name \u201cgezq0601\u201d git config --global user.email \u201cge051799qi@qq.com\u201d \u5b8c\u6210\u540e\u53ef\u8f93\u5165\u4e0b\u9762\u8bed\u53e5\u67e5\u770bGit\u7684\u914d\u7f6e\u4fe1\u606f\u3002 git config --list","title":"Git"},{"location":"software/git/#_1","text":"Git - Downloads (git-scm.com) \u7565.........\uff08\u66f4\u6539\u5b89\u88c5\u4f4d\u7f6e\u3001\u52fe\u9009\u6dfb\u52a0\u5230Path\u73af\u5883\u53d8\u91cf\uff0c\u4e4b\u540e\u4e00\u76f4next\u5373\u53ef\uff09\u3002","title":"\u5b89\u88c5"},{"location":"software/git/#_2","text":"\u6253\u5f00cmd\u7a97\u53e3\u6216PowerShell\u7a97\u53e3\uff0c\u8f93\u5165\u4e0b\u9762\u8bed\u53e5\u770b\u662f\u5426\u6b63\u786e\u663e\u793aGit\u7684\u7248\u672c\u3002 git --version \u82e5\u663e\u793aGit\u4e0d\u662f\u547d\u4ee4\uff0c\u5219\u5c1d\u8bd5\u5728\u73af\u5883\u53d8\u91cfPATH\u4e2d\u6dfb\u52a0Git\u7684\u5b89\u88c5\u76ee\u5f55\u4e0b\u7684bin\u5b50\u76ee\u5f55\uff08\u5982D:\\Git\\bin\uff09\u3002","title":"\u6d4b\u8bd5"},{"location":"software/git/#_3","text":"\u6253\u5f00cmd\u7a97\u53e3\u6216PowerShell\u7a97\u53e3\uff0c\u8f93\u5165\u4e0b\u9762\u8bed\u53e5\u8bbe\u7f6eGit\u7684user\u76f8\u5173\u4fe1\u606f\u3002 git config --global user.name \u201cgezq0601\u201d git config --global user.email \u201cge051799qi@qq.com\u201d \u5b8c\u6210\u540e\u53ef\u8f93\u5165\u4e0b\u9762\u8bed\u53e5\u67e5\u770bGit\u7684\u914d\u7f6e\u4fe1\u606f\u3002 git config --list","title":"\u914d\u7f6e"},{"location":"software/typora/","text":"\u5b89\u88c5 Typora \u5b98\u65b9\u4e2d\u6587\u7ad9 (typoraio.cn) \u7565......... \u6fc0\u6d3b Typora\u6fc0\u6d3b (github.com) \u5c06\"license-gen.exe\"\u4e0e\"node_inject.exe\"\u590d\u5236\u7c98\u8d34\u5230Typora\u5b89\u88c5\u76ee\u5f55\u4e0b\u3002 \u5728Typora\u5b89\u88c5\u76ee\u5f55\u4e2d\u6253\u5f00cmd\u7a97\u53e3\u6216PowerShell\u7a97\u53e3\u3002 \u5728\u7a97\u53e3\u547d\u4ee4\u884c\u8f93\u5165\"node_inject.exe\"\u5e76\u56de\u8f66\uff0c\u8fd0\u884c\u540e\u663e\u793a\"done!\"\u3002 \u5728\u7a97\u53e3\u547d\u4ee4\u884c\u8f93\u5165\"license-gen.exe\"\u5e76\u56de\u8f66\uff0c\u590d\u5236\u751f\u6210\u7684License\u3002 \u6253\u5f00Typora\u8f93\u5165\u751f\u6210\u7684License\uff0c\u90ae\u7bb1\u4efb\u610f\u586b\u5199\u5373\u53ef\u3002 \u504f\u597d\u8bbe\u7f6e \u201c\u6587\u4ef6\u201d\u9009\u9879\uff1a\u52fe\u9009\u201c\u5927\u7eb2\u201d\u2014\u2014\u201c\u5141\u8bb8\u6298\u53e0\u548c\u5c55\u5f00\u4fa7\u8fb9\u680f\u7684\u5927\u7eb2\u89c6\u56fe\u201d\u3002 \u201cMarkdown\u201d\u9009\u9879\uff1a\u52fe\u9009\u201cMarkdown\u6269\u5c55\u8bed\u6cd5\u201d\u7684\u5168\u90e8\u9009\u9879\u3002 \u4e0a\u4f20\u56fe\u7247 Github GitHub \u65b0\u5efa\u4e00\u4e2aRepository\u2014\u2014\u5982\u547d\u540d\u4e3aPictures\u3002 \u83b7\u53d6Token\u2014\u2014\u70b9\u51fb\u53f3\u4fa7\u4e2a\u4eba\u5934\u50cf--->\u70b9\u51fb\"Setting\"--->\u9009\u62e9\"Developer settings\"--->\u5728\"Personal access tokens\"\u4e2d\u9009\u62e9\"Token(classic)\"--->\u5728\"Generate new token\"\u4e2d\"Generate new token(classic)\"--->\"Note\"\u4efb\u610f\u586b\u5199\u3001\"Expiration\"\u9009\u62e9\"no expiration date\"\u3001\"Select scopes\"\u91cd\u70b9\u52fe\u9009\"repo\"\u9009\u9879\uff0c\u5b8c\u6210\u540e\u70b9\"Generate\"\u5373\u53ef\u751f\u6210\uff0c\u590d\u5236\u5e76\u4fdd\u5b58\u6b64Token\u3002 PicGo \u4e0b\u8f7d\u5e76\u5b89\u88c5\uff1a PicGo (github.com) \u914d\u7f6eGithub\u56fe\u5e8a\u3002 Typora \u8fdb\u5165Typora\u7684\u201d\u504f\u597d\u8bbe\u7f6e\u201c\u2014\u2014\u201d\u56fe\u50cf\u201c\u9009\u9879\u3002 \u201c\u63d2\u5165\u56fe\u7247\u65f6\u201d\u9009\u9879\uff1a\u9009\u62e9\u201d\u4e0a\u4f20\u56fe\u7247\u201c\uff0c\u5e76\u52fe\u9009\u201c\u5bf9\u672c\u5730\u4f4d\u7f6e\u7684\u56fe\u7247\u5e94\u7528\u4e0a\u8ff0\u89c4\u5219\u201d\u3002 \u201c\u4e0a\u4f20\u670d\u52a1\u8bbe\u5b9a\u201d\u9009\u9879\uff1a\u9009\u62e9\"PicGo(app)\"\uff0c\u5e76\u9009\u62e9PicGo\u8def\u5f84\uff08\u627e\u5230PicGo.exe\u7684\u4f4d\u7f6e\uff09\u3002 \u70b9\u51fb\u201c\u9a8c\u8bc1\u56fe\u7247\u4e0a\u4f20\u9009\u9879\u201d\uff0c\u51fa\u73b0\u5982\u4e0b\u6548\u679c\u5373\u4ee3\u8868\u6210\u529f\u3002","title":"Typora"},{"location":"software/typora/#_1","text":"Typora \u5b98\u65b9\u4e2d\u6587\u7ad9 (typoraio.cn) \u7565.........","title":"\u5b89\u88c5"},{"location":"software/typora/#_2","text":"Typora\u6fc0\u6d3b (github.com) \u5c06\"license-gen.exe\"\u4e0e\"node_inject.exe\"\u590d\u5236\u7c98\u8d34\u5230Typora\u5b89\u88c5\u76ee\u5f55\u4e0b\u3002 \u5728Typora\u5b89\u88c5\u76ee\u5f55\u4e2d\u6253\u5f00cmd\u7a97\u53e3\u6216PowerShell\u7a97\u53e3\u3002 \u5728\u7a97\u53e3\u547d\u4ee4\u884c\u8f93\u5165\"node_inject.exe\"\u5e76\u56de\u8f66\uff0c\u8fd0\u884c\u540e\u663e\u793a\"done!\"\u3002 \u5728\u7a97\u53e3\u547d\u4ee4\u884c\u8f93\u5165\"license-gen.exe\"\u5e76\u56de\u8f66\uff0c\u590d\u5236\u751f\u6210\u7684License\u3002 \u6253\u5f00Typora\u8f93\u5165\u751f\u6210\u7684License\uff0c\u90ae\u7bb1\u4efb\u610f\u586b\u5199\u5373\u53ef\u3002","title":"\u6fc0\u6d3b"},{"location":"software/typora/#_3","text":"\u201c\u6587\u4ef6\u201d\u9009\u9879\uff1a\u52fe\u9009\u201c\u5927\u7eb2\u201d\u2014\u2014\u201c\u5141\u8bb8\u6298\u53e0\u548c\u5c55\u5f00\u4fa7\u8fb9\u680f\u7684\u5927\u7eb2\u89c6\u56fe\u201d\u3002 \u201cMarkdown\u201d\u9009\u9879\uff1a\u52fe\u9009\u201cMarkdown\u6269\u5c55\u8bed\u6cd5\u201d\u7684\u5168\u90e8\u9009\u9879\u3002","title":"\u504f\u597d\u8bbe\u7f6e"},{"location":"software/typora/#_4","text":"","title":"\u4e0a\u4f20\u56fe\u7247"},{"location":"software/typora/#github","text":"GitHub \u65b0\u5efa\u4e00\u4e2aRepository\u2014\u2014\u5982\u547d\u540d\u4e3aPictures\u3002 \u83b7\u53d6Token\u2014\u2014\u70b9\u51fb\u53f3\u4fa7\u4e2a\u4eba\u5934\u50cf--->\u70b9\u51fb\"Setting\"--->\u9009\u62e9\"Developer settings\"--->\u5728\"Personal access tokens\"\u4e2d\u9009\u62e9\"Token(classic)\"--->\u5728\"Generate new token\"\u4e2d\"Generate new token(classic)\"--->\"Note\"\u4efb\u610f\u586b\u5199\u3001\"Expiration\"\u9009\u62e9\"no expiration date\"\u3001\"Select scopes\"\u91cd\u70b9\u52fe\u9009\"repo\"\u9009\u9879\uff0c\u5b8c\u6210\u540e\u70b9\"Generate\"\u5373\u53ef\u751f\u6210\uff0c\u590d\u5236\u5e76\u4fdd\u5b58\u6b64Token\u3002","title":"Github"},{"location":"software/typora/#picgo","text":"\u4e0b\u8f7d\u5e76\u5b89\u88c5\uff1a PicGo (github.com) \u914d\u7f6eGithub\u56fe\u5e8a\u3002","title":"PicGo"},{"location":"software/typora/#typora","text":"\u8fdb\u5165Typora\u7684\u201d\u504f\u597d\u8bbe\u7f6e\u201c\u2014\u2014\u201d\u56fe\u50cf\u201c\u9009\u9879\u3002 \u201c\u63d2\u5165\u56fe\u7247\u65f6\u201d\u9009\u9879\uff1a\u9009\u62e9\u201d\u4e0a\u4f20\u56fe\u7247\u201c\uff0c\u5e76\u52fe\u9009\u201c\u5bf9\u672c\u5730\u4f4d\u7f6e\u7684\u56fe\u7247\u5e94\u7528\u4e0a\u8ff0\u89c4\u5219\u201d\u3002 \u201c\u4e0a\u4f20\u670d\u52a1\u8bbe\u5b9a\u201d\u9009\u9879\uff1a\u9009\u62e9\"PicGo(app)\"\uff0c\u5e76\u9009\u62e9PicGo\u8def\u5f84\uff08\u627e\u5230PicGo.exe\u7684\u4f4d\u7f6e\uff09\u3002 \u70b9\u51fb\u201c\u9a8c\u8bc1\u56fe\u7247\u4e0a\u4f20\u9009\u9879\u201d\uff0c\u51fa\u73b0\u5982\u4e0b\u6548\u679c\u5373\u4ee3\u8868\u6210\u529f\u3002","title":"Typora"}]}